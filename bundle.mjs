import e from"@ki1r0y/distributed-security";export{default as Credentials}from"@ki1r0y/distributed-security";const t=/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;function n(){var e=URL.createObjectURL(new Blob),t=e.toString();return URL.revokeObjectURL(e),t.split(/[:\/]/g).pop().toLowerCase()}n.valid=function(e){return t.test(e)};var s=globalThis;const i=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:freestun.net:3478"},{urls:"turn:turn.speed.cloudflare.com:50000",username:"826226244cd6e5edb3f55749b796235f420fe5ee78895e0dd7d2baa45e1f7a8f49e9239e78691ab38b72ce016471f7746f5277dcef84ad79fc60f8020b132c73",credential:"aba9b169546eb6dcc7bfb1cdf34544cf95b5161d602e3b5fa7c8342b2e9802fb"}];class a{constructor({label:e="",configuration:t=null,uuid:s=n(),debug:a=!1,...r}={}){t??={iceServers:i},Object.assign(this,{label:e,configuration:t,uuid:s,debug:a,...r}),this.resetPeer()}signal(e,t){this.log("sending",e,e.length,JSON.stringify(t).length)}peerVersion=0;resetPeer(){const e=this.peer;e&&(e.onnegotiationneeded=e.onicecandidate=e.onicecandidateerror=e.onconnectionstatechange=null,"new"!==e.connectionState&&e.close());const t=this.peer=new s.RTCPeerConnection(this.configuration);t.versionId=this.peerVersion++,t.onnegotiationneeded=e=>this.negotiationneeded(e),t.onicecandidate=e=>this.onLocalIceCandidate(e),t.onicecandidateerror=e=>this.icecandidateError(e),t.onicegatheringstatechange=e=>"complete"===t.iceGatheringState&&this.onLocalEndIce,t.onconnectionstatechange=e=>this.connectionStateChange(this.peer.connectionState)}onLocalIceCandidate(e){e.candidate&&e.candidate.candidate?this.signal("icecandidate",e.candidate):this.onLocalEndIce()}onLocalEndIce(){}close(){"new"===this.peer.connectionState&&"stable"===this.peer.signalingState||this.resetPeer()}connectionStateChange(e){this.log("state change:",e),["disconnected","failed","closed"].includes(e)&&this.close()}negotiationneeded(){this.log("negotiationnneeded"),this.peer.createOffer().then((e=>(this.peer.setLocalDescription(e),e))).then((e=>this.signal("offer",e))).catch((e=>this.negotiationneededError(e)))}offer(e){this.peer.setRemoteDescription(e).then((e=>this.peer.createAnswer())).then((e=>this.peer.setLocalDescription(e))).then((e=>this.signal("answer",this.peer.localDescription)))}answer(e){this.peer.setRemoteDescription(e)}icecandidate(e){this.peer.addIceCandidate(e).catch((e=>this.icecandidateError(e)))}log(...e){this.debug&&console.log(this.label,this.peer.versionId,...e)}logError(e,t){const n=[this.label,this.peer.versionId,...this.constructor.gatherErrorData(e,t)];return console.error.apply(console,n),n}static gatherErrorData(e,t){return[e+" error:",t.code||t.errorCode||t.status||"",t.url||t.name||"",t.message||t.errorText||t.statusText||t]}icecandidateError(e){701!==(e.code||e.errorCode||e.status)&&this.logError("ice",e)}}class r extends a{constructor({iceTimeout:e=2e3,...t}){super(t),this.iceTimeout=e}get signals(){return this._signalPromise||=new Promise(((e,t)=>this._signalReady={resolve:e,reject:t}))}set signals(e){e.forEach((([e,t])=>this[e](t)))}onLocalIceCandidate(e){this.timer||=setTimeout((()=>this.onLocalEndIce()),this.iceTimeout),super.onLocalIceCandidate(e)}clearIceTimer(){clearTimeout(this.timer),this.timer=null}async onLocalEndIce(){this.clearIceTimer(),this._signalPromise&&(this._signalReady.resolve(this.sending),this.sending=[])}sending=[];signal(e,t){super.signal(e,t),this.sending.push([e,t])}dataChannels=new Map;reportChannels(){const e=Array.from(this.dataChannels.entries()).map((([e,t])=>`${e}:${t.id}`));return`${this.dataChannels.size}/${e.join(", ")}`}noteChannel(e,t,n){const s=e.label;return this.dataChannels.get(s)&&!n||(this.dataChannels.set(s,e),e.addEventListener("close",(e=>{this.dataChannels.delete(s),this.dataChannels.size||this.peer.getSenders().length||this.close()}))),e}createDataChannel(e="data",t={}){return new Promise((async n=>{let s=this.peer.createDataChannel(e,t);this.noteChannel(s,"explicit"),"open"===s.readyState?setTimeout((()=>n(s)),10):s.onopen=e=>{n(s)}}))}waitingChannels={};getDataChannelPromise(e="data"){return new Promise((t=>{this.waitingChannels[e]=t}))}resetPeer(){super.resetPeer(),this.connected=new Promise((e=>{this.peer.addEventListener("connectionstatechange",(t=>{"connected"===this.peer.connectionState&&e(!0)}))})),this.peer.addEventListener("datachannel",(e=>{const t=e.channel,n=t.label,s=this.waitingChannels[n];this.noteChannel(t,"datachannel event",s),s&&(delete this.waitingChannels[n],s(t))}))}close(){"failed"===this.peer.connectionState&&this._signalPromise?.reject?.(),super.close(),this.clearIceTimer(),this._signalPromise=this._signalReady=null,this.sending=[]}}const o=1e3;class c extends r{static connections=new Map;static ensure({serviceLabel:e,multiplex:t=!0,...s}){let i=this.connections.get(e);return i||(i=new this({label:e,uuid:n(),multiplex:t,...s}),t&&this.connections.set(e,i)),i}channelId=o;get hasStartedConnecting(){return this.channelId>o}close(e=!0){this.channelId=o,super.close(),e&&this.constructor.connections.delete(this.serviceLabel)}async ensureDataChannel(e,t={},n=null){const s=this.hasStartedConnecting,i=this.channelId++,a="negotiated"===this.multiplex&&s,r=!s/*!negotiated*/&&!!n,o=!s&&n?.length,c=a?{id:i,negotiated:a,...t}:t;s?await this.connected:o&&(this.signals=n);const h=r?this.getDataChannelPromise(e):this.createDataChannel(e,c);return await h}}var h={name:"@kilroy-code/flexstore",version:"0.0.27",description:"Safe and private storage replicated between clients and relays, with realtime updates.",main:"index.mjs",imports:{"#wrtc":{node:"@roamhq/wrtc",default:"./lib/browser-wrtc.mjs"},"#persist":{node:"./lib/persist-fs.mjs",default:"./lib/persist-indexeddb.mjs"}},scripts:{test:"jasmine",build:"rollup -c","build-dev":"npx rollup -c --environment NODE_ENV:development"},repository:{type:"git",url:"git+https://github.com/kilroy-code/flexstore.git"},publishConfig:{registry:"https://npm.pkg.github.com"},keywords:["key-value","storage","p2p","client","server","relay","end-to-end","encryption","cryptography","signed","privacy"],author:"howard@ki1r0y.com",license:"MIT",bugs:{url:"https://github.com/kilroy-code/flexstore/issues"},homepage:"https://github.com/kilroy-code/flexstore#readme",dependencies:{"@ki1r0y/distributed-security":"^1.1.3","@roamhq/wrtc":"^0.8.0",uuid4:"^2.0.3"},devDependencies:{"@rollup/plugin-json":"^6.1.0","@rollup/plugin-node-resolve":"15.3","@rollup/plugin-terser":"^0.4.4",jasmine:"^5.7.1",rollup:"4.27"}};const l="flexstore",d=4,{name:u,version:g}=h;class m{constructor({serviceName:e="direct",collection:t,serviceLabel:n=t?.serviceLabel||e,channelName:s,uuid:i,rtcConfiguration:a,connection:r,multiplex:o=t?.multiplex,debug:h=t?.debug,minVersion:l=4,maxVersion:d=l}){const u=e.startsWith?.("http");u||void 0!==a||(a={}),o??=r?.multiplex,o??=e.includes?.("/sync")||"negotiated",r??=c.ensure({serviceLabel:n,configuration:a,multiplex:o,debug:h}),i??=r.uuid,s??=t?.channelName||t.fullName;const g=`${t?.fullLabel||s}/${i}`,m=e.includes?.("/signal/")?e:`${e}/${g}`;Object.assign(this,{serviceName:e,label:g,collection:t,debug:h,minVersion:l,maxVersion:d,uuid:i,rtcConfiguration:a,connection:r,uuid:i,channelName:s,connectionURL:m,connectionStartTime:Date.now(),closed:this.makeResolveablePromise(),hostRequestBase:u&&`${e.replace(/\/(sync|signal)/)}/${s}`}),t?.synchronizers.set(e,this)}static async create(e,t,n={}){const s=new this({collection:e,serviceName:t,...n}),i=s.connectChannel(),a=await i;return a?await a.synchronize():s}async connectChannel(){const{hostRequestBase:e,uuid:t,connection:n,serviceName:s}=this;let i=n.hasStartedConnecting;if(i)this.dataChannelPromise=n.ensureDataChannel(this.channelName),await this.dataChannelPromise;else if(this.connectionURL.includes("/signal/answer"))i=await this.connectServer();else if(this.connectionURL.includes("/signal/offer")){const e=this.startConnection([]),t=this.connectionURL,n=await this.fetch(t);this.completeConnection(n),i=await e,await this.fetch(t,i)}else if(this.connectionURL.includes("/sync"))i=await this.connectServer();else{if("signals"===s)return await this.startConnection(),null;if(Array.isArray(s))await this.startConnection(s);else{if(!s.synchronizers)throw new Error(`Unrecognized service format: ${s}.`);i=await this.connectDirectTesting(s)}}return i?this:(console.warn(this.label,"connection failed"),null)}log(...e){this.debug&&console.log(this.label,...e)}get dataChannelPromise(){const e=this._dataChannelPromise;if(!e)throw new Error(`${this.label}: Data channel is not yet promised.`);return e}channelClosedCleanup(){this.collection?.synchronizers.delete(this.serviceName),this.closed.resolve(this)}set dataChannelPromise(e){this._dataChannelPromise=e.then((e=>(e.onmessage=e=>this.receive(e.data),e.onclose=async e=>this.channelClosedCleanup(),e)))}async synchronize(){return await this.dataChannelPromise,await this.startedSynchronization,this}static fragmentId=0;async send(e,...t){const n=JSON.stringify({method:e,params:t}),s=await this.dataChannelPromise,i=s?.readyState||"closed";if("closed"===i||"closing"===i)return;this.log("sends",e,...t);const a=16e3;if(n.length<a)return void s.send(n);const r=Math.ceil(n.length/a),o=this.constructor.fragmentId++,c={method:"fragments",params:[o,r]};s.send(JSON.stringify(c));for(let e=0,t=0;e<r;++e,t+=a){const i={method:"frag",params:[o,e,n.substr(t,a)]};s.send(JSON.stringify(i))}}receive(e){const{method:t,params:n}=JSON.parse(e);this[t](...n)}pendingFragments={};fragments(e,t){this.pendingFragments[e]={remaining:t,message:Array(t)}}frag(e,t,n){let s=this.pendingFragments[e];s.message[t]=n,0===--s.remaining&&(this.receive(s.message.join("")),delete this.pendingFragments[e])}async disconnect(){if("connected"!==this.connection.peer.connectionState)return this.channelClosedCleanup(this.connection.close());return(await this.dataChannelPromise).close(),this.closed}async startConnection(e){const{connection:t}=this;return this.log(e?"generating answer":"generating offer"),this.dataChannelPromise=t.ensureDataChannel(this.channelName,{},e),t.signals}completeConnection(e){return this.connection.signals=e,!0}async fetch(e,t=null){const n=t?"POST":"GET";this.debug&&this.log(n,"signals",e,JSON.stringify(t,null,2));const s=await fetch(e,t?{method:n,headers:{"Content-Type":"application/json"},body:JSON.stringify(t)}:{method:n}),i=await s.json();return this.debug&&this.log(n,"responseSignals",e,JSON.stringify(i,null,2)),i}async connectServer(e=this.connectionURL){const t=await this.startConnection(),n=await this.fetch(e,t);return this.completeConnection(n)}async completeSignalsSynchronization(e){await this.completeConnection(e),await this.synchronize()}async connectDirectTesting(e){const t=e.synchronizers.get(this.collection);if(!t)return this._delay=this.makeResolveablePromise(),!1;const n=await this.startConnection(),s=await t.startConnection(n);return t._delay.resolve(),this.completeConnection(s)}makeResolveablePromise(e){let t;const n=new Promise((e=>t=e));return n.resolve=t,n}async versions(e,t){let n=this.version;const s=Math.min(t,this.maxVersion);return s>=Math.max(e,this.minVersion)?n.resolve(s):n.resolve(0)}get version(){return this._version||=this.makeResolveablePromise(setTimeout((()=>this.send("versions",this.minVersion,this.maxVersion)),200))}get startedSynchronization(){return this._startedSynchronization||=this.startSynchronization()}get completedSynchronization(){return this._completedSynchronization||=this.makeResolveablePromise(this.startedSynchronization)}get peerCompletedSynchronization(){return this._peerCompletedSynchronization||=this.makeResolveablePromise()}get bothSidesCompletedSynchronization(){return this.completedSynchronization.then((()=>this.peerCompletedSynchronization))}async reportConnection(){const e=await this.connection.peer.getStats();let t;for(const n of e.values())if("transport"===n.type){t=n;break}let n=t&&e.get(t.selectedCandidatePairId);if(!n)for(const t of e.values())if("candidate-pair"===t.type&&t.selected){n=t;break}if(!n)return void console.warn(this.label,"got stats without candidatePair",Array.from(e.values()));const s=e.get(n.remoteCandidateId),{protocol:i,candidateType:a}=s,r=Date.now();Object.assign(this,{stats:e,transport:t,candidatePair:n,remote:s,protocol:i,candidateType:a,synchronizationStartTime:r}),console.info(this.label,"connected",i,a,((r-this.connectionStartTime)/1e3).toFixed(1))}async startSynchronization(){if(!await this.dataChannelPromise)throw new Error(`No connection for ${this.label}.`);await this.reportConnection();const[e,t]=await Promise.all([this.version,this.collection.tags]);Object.assign(this,{ourTags:t,synchronized:new Set,unsynchronized:new Map,endOfPeerTags:!1}),this.streamTags(t)}async computeHash(t){const n=await e.hashText(t);return e.encodeBase64url(n)}async getHash(e){const t=await this.collection.get(e);return this.computeHash(t||"missing")}async streamTags(e){for(const t of e)this.send("hash",t,await this.getHash(t));this.send("endTags")}async endTags(){await this.startedSynchronization,this.endOfPeerTags=!0,this.cleanUpIfFinished()}synchronizationComplete(e){this.peerCompletedSynchronization.resolve(e)}cleanUpIfFinished(){if(!this.endOfPeerTags||this.unsynchronized.size)return;const e=this.synchronized.size;this.send("synchronizationComplete",e),this.synchronized.clear(),this.unsynchronized.clear(),this.ourTags=this.synchronized=this.unsynchronized=null,console.info(this.label,"completed synchronization",e,"items in",((Date.now()-this.synchronizationStartTime)/1e3).toFixed(1),"seconds"),this.completedSynchronization.resolve(e)}synchronizationPromise(e){return!this.unsynchronized||(!!this.synchronized.has(e)||(this.unsynchronized.get(e)||this.noteRequest(e,"",this.getHash(e))))}async hash(e,t){await this.startedSynchronization;const{ourTags:n,unsynchronized:s}=this;return s.has(e)?null:n.has(e)?this.noteRequest(e,t,this.getHash(e)):this.noteRequest(e,t)}noteRequest(e,t="",n=null){const s=new Promise((s=>{setTimeout((async()=>{if(!t||!n||t!==await n){const s=await this.request(e);t&&!s?.length||(await this.collection.put(e,s,this)?this.log("received/put",e,"their/our hash:",t||"missingTheirs",await n||"missingOurs",s?.length):this.log("unable to put",e)),this.synchronized.add(e)}this.unsynchronized.delete(e),this.cleanUpIfFinished(),s()}))}));return this.unsynchronized.set(e,s),s}request(e){const t=this.makeResolveablePromise(this.send("get",e));return this.unsynchronized.get(e).resolve=t.resolve,t}async get(e){const t=await this.collection.get(e);this.push("put",e,t)}push(e,t,n){this.send(e,t,n)}async put(e,t){const n=this.unsynchronized?.get(e);n?n.resolve(t):await this.collection.put(e,t,this)}delete(e,t){this.collection.delete(e,t,this)}}class p{constructor({collection:e,collectionLabel:t=e.fullLabel,dbName:n=l,dbVersion:s=4}={}){this.db_name=t,this.objectStore_name=`${n}:${s}`}get db(){return this._db??=new Promise((e=>{const t=indexedDB.open(this.db_name,this.db_version);t.onupgradeneeded=({oldVersion:e,newVersion:t,target:n})=>this.upgrade(n.result,e,t),this.result(e,t)}))}upgrade(e,t,n){const{objectStore_name:s}=this;e.objectStoreNames.contains(s)||e.createObjectStore(s)}transaction(e="read"){const{objectStore_name:t}=this;return this.db.then((n=>n.objectStoreNames.contains(t)?n.transaction(t,e).objectStore(t):(this._db=null,this.db_version=n.version+1,n.close(),this.transaction(e))))}result(e,t){t.onsuccess=t=>e(t.target.result||"")}list(){return new Promise((e=>{this.transaction("readonly").then((t=>this.result(e,t.getAllKeys())))}))}get(e){return new Promise((t=>{this.transaction("readonly").then((n=>this.result(t,n.get(e))))}))}put(e,t){return new Promise((n=>{this.transaction("readwrite").then((s=>this.result(n,s.put(t,e))))}))}delete(e){return new Promise((t=>{this.transaction("readwrite").then((n=>this.result(t,n.delete(e))))}))}async close(){return this._db?((await this.db).close(),new Promise((e=>setTimeout(e,1e3)))):null}async destroy(){await this.close();const e=window.indexedDB.deleteDatabase(this.db_name);return new Promise(((t,n)=>{e.onsuccess=setTimeout(t,1e3),e.onerror=n}))}}const{CustomEvent:y,EventTarget:w,TextDecoder:f}=globalThis;class b extends w{static Persist=p;constructor({name:e,label:t=e,services:n=[],preserveDeletions:s=!!n.length,persistenceClass:i=b.Persist,dbVersion:a=4,debug:r=!1,multiplex:o,channelName:c,serviceLabel:h}){super(),Object.assign(this,{name:e,label:t,preserveDeletions:s,persistenceClass:i,dbVersion:a,multiplex:o,debug:r,channelName:c,serviceLabel:h,fullName:`${this.constructor.name}/${e}`,fullLabel:`${this.constructor.name}/${t}`}),this.synchronize(...n),i.then?this.persistenceStore=i.then((e=>new e({collection:this}))):this.persistenceStore=new i({collection:this})}async close(){await(await this.persistenceStore).close()}async destroy(){await(await this.persistenceStore).destroy()}static ensureString(e){return"string"!=typeof e?JSON.stringify(e):e}static maybeInflate(e){return e?.startsWith?.("{")?JSON.parse(e):e}static encryptedMimeType="text/encrypted";static async ensureDecrypted(t){if(t.protectedHeader.cty!==this.encryptedMimeType)return t;const n=await e.decrypt(t.text);return t.json=n.json,t.text=n.text,t.payload=n.payload,t.decrypted=n,t}static async sign(t,n){const s=await e.sign(t,n);return this.ensureString(s)}static async verify(t,n={}){t=this.maybeInflate(t);const s=await e.verify(t,n);return s&&(s.signature=t),s}static async verifiedSign(e,t,n=null){const s=await this.sign(e,t);return this.validationFormat(s,n)}static async validationFormat(e,t=null){console.log({type:typeof e,signature:e,tag:t});const n=await this.verify(e);console.log({verified:n});const s=n.subjectTag=n.protectedHeader.sub;return n.tag=t||s,n}async undeletedTags(){const e=await(await this.persistenceStore).list(),t=new Set;return await Promise.all(e.map((async e=>{await this.getVerified({tag:e,synchronize:!1})&&t.add(e)}))),t}get tags(){return this._tagsPromise||=this.undeletedTags()}async addTag(e){(await this.tags).add(e)}async deleteTag(e){(await this.tags).delete(e)}log(...e){this.debug&&console.log(this.fullLabel,...e)}_canonicalizeOptions(t={}){"string"==typeof t&&(t={tag:t});const{owner:n=e.owner,author:s=e.author,tag:i,encryption:a=e.encryption,time:r=Date.now(),...o}=t,c=n&&n!==s?{team:n,member:s,tag:i,encryption:a,time:r,...o}:{tags:[s],tag:i,time:r,encryption:a,...o};return[!0,"team","owner"].includes(c.encryption)&&(c.encryption=n),c}fail(e,t,n){throw new Error(`${n} does not have the authority to ${e} ${JSON.stringify(t)}.`)}async store(t,n={}){let{encryption:s,tag:i,...a}=this._canonicalizeOptions(n);s&&(t=await e.encrypt(t,s),a.contentType=this.constructor.encryptedMimeType);const r=await this.constructor.sign(t,a);return i=await this.put(i,r),i?(await this.push("put",i,r),i):this.fail("store",t,a.member||a.tags[0])}push(e,t,n,s=null){return Promise.all(this.mapSynchronizers((i=>s!==i&&i.push(e,t,n))))}async remove(e={}){let{encryption:t,tag:n,...s}=this._canonicalizeOptions(e);const i=await this.constructor.sign("",s);return n=await this.delete(n,i),n?(await this.push("delete",n,i),n):this.fail("store","",s.member||s.tags[0])}async retrieve(e){const{tag:t,decrypt:n=!0,...s}=e.tag?e:{tag:e},i=await this.getVerified({tag:t,...s});return i&&n?await this.constructor.ensureDecrypted(i):i}async getVerified(e){const{tag:t,synchronize:n=!0,...s}=e.tag?e:{tag:e};n&&await this.synchronize1(t);const i=await this.get(t);return i?this.constructor.verify(i,s):i}async list(e=!1){return e||await this.synchronizeTags(),Array.from((await this.tags).keys())}async match(e,t){const n=await this.retrieve(e),s=n?.json;if(!s)return!1;for(const e in t)if(s[e]!==t[e])return!1;return!0}async findLocal(e){for(const t of await this.list("no-sync"))if(await this.match(t,e))return t;return!1}async find(e){let t=await this.findLocal(e);return t&&(await this.synchronize1(t),await this.match(t,e))?t:(await this.synchronizeTags(),await this.synchronizeData(),t=await this.findLocal(e),t&&await this.match(t,e)?t:null)}requireTag(e){if(!e)throw new Error("A tag is required.")}async get(e){return this.requireTag(e),await(await this.persistenceStore).get(e)}async put(e,t,n=null,s=null){const i=await this.validateForWriting(e,t,"store",n);if(this.log("put",e,n?.label,"validated:",i),!i)return;await this.addTag(i.tag);const a=await this.mergeSignatures(e,i,t,s);return await this.persist(i.tag,a),i.tag}async delete(e,t,n=null){const s=await this.validateForWriting(e,t,"remove",n,"requireTag");if(this.log("delete",e,n?.label,"validated tag:",s?.tag,"preserveDeletions:",this.preserveDeletions),s)return await this.deleteTag(e),this.preserveDeletions?await this.persist2(s):await this.persist2(s,"delete"),s.tag}notifyInvalid(e,t,n=void 0,s="",i){console.warn(this.fullLabel,t,n,e)}async disallowWrite(e,t,n,s){return n?t?n.iat<t.iat?"backdated":this.ownerMatch(t,n)?await this.subjectMatch(s)?null:"wrong hash":"not owner":null:"invalid signature"}async subjectMatch(t){return t.protectedHeader.sub===await e.encodeBase64url(await e.hashBuffer(t.payload))}ownerMatch(e,t){const n=e?.iss||e?.kid,s=t.iss||t.kid;return!(!s||n&&s!==n)}antecedent(e){return e.tag}synchronizeAntecedent(e,t){return e!==t}async validateForWriting(e,t,n,s,i=!1){const a=s?{member:null}:{},r=await this.constructor.verify(t,a);if(!r)return this.notifyInvalid(e,n,"invalid",r,t);r.synchronizer=s,e=r.tag=r.subjectTag=i?e:await this.tagForWriting(e,r);const o=this.antecedent(r),c=this.synchronizeAntecedent(e,o),h=r.existing=o&&await this.getVerified({tag:o,synchronize:c}),l=await this.disallowWrite(e,h?.protectedHeader,r?.protectedHeader,r);return l?this.notifyInvalid(e,n,l,r):(this.emit(r),r)}mergeSignatures(e,t,n){return n}async persist(e,t,n="put"){return(await this.persistenceStore)[n](e,t)}mergeValidation(e){return e}async persist2(e,t="put"){const{tag:n,signature:s}=e,i=this.constructor.ensureString(s),a=await this.persistenceStore;return await a[t](n,i),n}emit(e){this.dispatchEvent(new y("update",{detail:e}))}get itemEmitter(){return this}synchronizers=new Map;mapSynchronizers(e){const t=[];for(const n of this.synchronizers.values())t.push(e(n));return t}get services(){return Array.from(this.synchronizers.keys())}async synchronize(...e){const{synchronizers:t}=this;for(let n of e)t.has(n)||await m.create(this,n)}get synchronized(){return Promise.all(this.mapSynchronizers((e=>e.bothSidesCompletedSynchronization)))}async disconnect(...e){e.length||(e=this.services);const{synchronizers:t}=this;for(let n of e){const e=t.get(n);e&&await e.disconnect()}}async ensureSynchronizer(e,t,n){let s=this.synchronizers.get(e);if(s){if(s.connection!==t||s.channelName!==n.label||await s.dataChannelPromise!==n)throw new Error(`Unmatched connection for ${e}.`)}else s=new m({serviceName:e,collection:this,debug:this.debug}),s.connection=t,s.dataChannelPromise=Promise.resolve(n),this.synchronizers.set(e,s);return s}promise(e,t){return t}synchronize1(e){return Promise.all(this.mapSynchronizers((t=>t.synchronizationPromise(e))))}async synchronizeTags(){return this.promise("tags",(()=>Promise.resolve()))}async synchronizeData(){return this.promise("data",(()=>Promise.resolve()))}set onupdate(e){e?(this._update=e,this.addEventListener("update",e)):(this.removeEventListener("update",this._update),this._update=e)}get onupdate(){return this._update}}class v extends b{tagForWriting(e,t){return t.protectedHeader.sub}async disallowWrite(e,t,n,s){return n?t?!s.payload.length&&n.iat>t.iat?null:n.iat>t.iat?"rewrite":n.sub!==t.sub?"altered contents":null:s.length&&e!==n.sub?"wrong tag":await this.subjectMatch(s)?null:"wrong hash":"invalid signature"}}class z extends b{tagForWriting(e,t){return e||t.protectedHeader.sub}}class C extends z{async tagForWriting(t,n){if(t)return t;const s=n.protectedHeader.ant,i=n.text||(new f).decode(n.payload);return e.encodeBase64url(await e.hashText(s+i))}antecedent(e){const t=e?.protectedHeader;if(!t)return"";const n=t.ant;return"number"==typeof n?"":n}async subjectMatch(e){return!0}emit(e){e.subjectTag=e.protectedHeader.sub,super.emit(e)}}class S extends z{constructor({services:e=[],...t}={}){super(t),this.versions=new C(t),this.synchronize(...e)}async close(){await this.versions.close(),await super.close()}async destroy(){await this.versions.destroy(),await super.destroy()}recoverTag(e){return Object.assign({},e,{tag:e.protectedHeader.sub})}serviceForVersion(e){return e?.versions||e}servicesForVersion(e){return e.map((e=>this.serviceForVersion(e)))}async synchronize(...e){if(!e.length)return;const t=super.synchronize(...e),n=this.versions.synchronize(...this.servicesForVersion(e));await t,await n}async disconnect(...e){e.length||(e=this.services),await this.versions.disconnect(...this.servicesForVersion(e)),await super.disconnect(...e)}get synchronized(){return super.synchronized.then((()=>this.versions.synchronized))}get itemEmitter(){return this.versions}async getVersions(e){this.requireTag(e);const t=await this.getVerified({tag:e}),n=t?.json;if(!Array.isArray(n))return n;const s=await this.ensureExpanded(t);return this.combineTimestamps(e,null,...s.map((e=>e.json)))}async retrieveTimestamps(e){const t=await this.getVersions(e);return t?Object.keys(t).slice(1).map((e=>parseInt(e))):t}getActiveHash(e,t=e.latest){if(!e)return e;let n=e[t];if(n)return n;let s=0,i=Object.keys(e);for(let e=1;e<i.length&&i[e]<=t;e++)s=i[e];return e[s]}async retrieve(e){let{tag:t,time:n,hash:s}=!e||e.length?{tag:e}:e;if(!s){const e=await this.getVersions(t);if(!e)return e;if(s=this.getActiveHash(e,n),!s)return""}return this.versions.retrieve(s)}async store(t,n={}){let s,{tag:i,encryption:a,...r}=this._canonicalizeOptions(n),o=Date.now(),c=Object.assign({time:o,encryption:a},r);i&&(s=await this.getVersions(i)||{},c.sub=i,s&&(c.ant=s[s.latest])),c.ant||=o;const h=await this.versions.store(t,c);if(!i){const t=await this.versions.get(h);i=e.decodeClaims(this.constructor.maybeInflate(t)).sub,s={}}s.latest=o,s[o]=h;const l=await this.constructor.sign(s,r);return await this.addTag(i),await this.persist(i,l),this.emit({tag:i,subjectTag:i,...await this.constructor.verify(l)}),await this.push("put",i,l),i}async remove(e={}){let{encryption:t,tag:n,...s}=this._canonicalizeOptions(e);const i=await this.getVersions(n);if(!i)return i;if(this.preserveDeletions)await this.store("",s);else{const e=Object.values(i).slice(1),t=await this.constructor.sign("",{sub:n,...s});await Promise.all(e.map((async e=>{await this.versions.delete(e,t),await this.versions.push("delete",e,t)})));const a=await this.constructor.sign("",s);await this.persist(n,a,"delete"),await this.push("delete",n,a)}return await this.deleteTag(n),n}async mergeSignatures(t,n,s,i=null){let a=n,r=n.existing;if(!r)return s;n.protectedHeader.iat<n.existing.protectedHeader.iat&&([r,a]=[a,r]);let o=null;if(!Array.isArray(r.json)&&!Array.isArray(a.json)&&(o=this.missingKeys(r.json,a.json),!o.length))return this.constructor.ensureString(a.signature);const c=await this.ensureExpanded(r),h=await this.ensureExpanded(a),l=c[0].protectedHeader;let d,u,g=l.iss||l.kid,m=[e.owner,e.author,i].includes(g)||!i&&await e.sign("",g).catch((()=>!1)),p=Date.now();const y=i||e.author;function w(e,t){return[].concat(e,t)}if(m){function f(e){return e.map((e=>e.json))}const b=w(f(c),f(h));d=this.combineTimestamps(t,o,...b),u={team:g,member:y,time:p}}else{function v(e){return e.map((e=>e.signature))}d=w(v(c),v(h)),u={tags:[y],time:p}}return await this.constructor.sign(d,u)}ensureExpanded(e){return Array.isArray(e.json)?Promise.all(e.json.map((e=>this.constructor.verify(e)))):[e]}missingKeys(e,t){const n=new Set(Object.values(t));return Object.keys(e).filter((t=>"latest"!==t&&!n.has(e[t])))}combineTimestamps(e,t,n,s,...i){t||=this.missingKeys(n,s);const a={};let r,o,c=0;for(const i in s){if(r=0,"latest"!==i)for(;c<t.length&&(r=t[c])<i;c++)a[r]=n[r];if(r===i){console.warn(this.fullLabel,`Unusual matching timestamp case at time ${r} for tag ${e}.`),o||=Object.keys(s);const h=i+(Math.min(t[c+1]||1/0,s[o.indexOf(i)+1]||1/0)-i)/2;a[i]=n[i],a[h]=s[i]}else a[i]=s[i]}for(;c<t.length;c++)r=t[c],a[r]=n[r];let h=Object.keys(a);return a.latest=h[h.length-1],i.length?this.combineTimestamps(e,void 0,a,...i):a}static async verify(e,t={}){if(e.startsWith?.("[")&&(e=JSON.parse(e)),!Array.isArray(e))return await super.verify(e,t);const n=await Promise.all(e.map((e=>this.verify(e,t))));if(!n.every((e=>e)))return;const s=n[0].protectedHeader;for(const e of["iss","kid","alg","cty"]){const t=s[e],i=n.every((n=>n.protectedHeader[e]===t));if(!i&&!i)return}const{iss:i,kid:a,alg:r,cty:o}=s;return{signature:e,json:n.map((e=>e.json)),protectedHeader:{iss:i,kid:a,alg:r,cty:o,iat:Math.max(...n.map((e=>e.protectedHeader.iat)))}}}async disallowWrite(e,t,n,s){return n?t?this.ownerMatch(t,n)?await this.subjectMatch(s)?null:"wrong hash":"not owner":null:"invalid signature"}ownerMatch(e,t){return!0}}e.author=null,e.owner=null,e.encryption=null,e.synchronize=async(...t)=>Promise.all(Object.values(e.collections).map((e=>e.synchronize(...t)))),e.synchronized=async()=>Promise.all(Object.values(e.collections).map((e=>e.synchronized))),e.disconnect=async(...t)=>Promise.all(Object.values(e.collections).map((e=>e.disconnect(...t)))),e.createAuthor=async t=>{if("-"===t)return e.create(await e.create({prompt:t}));const[n,s]=await Promise.all([e.create(),e.create({prompt:t})]);return e.create(n,s)},e.claimInvitation=async(t,n)=>{const s=await e.collections.Team.retrieve({tag:t});if(!s)throw new Error(`Unable to verify invitation ${t}.`);const i=s.json.recipients;if(1!==i.length)throw new Error(`Invitations should have one member: ${t}`);const a=i[0].header.kid,r=await e.create({prompt:n}),o=await e.create();return await e.changeMembership({tag:t,add:[o,r],remove:[a]}),await e.destroy(a),t};const T={};e.setAnswer=(e,t)=>T[e]=t,e.getUserDeviceSecret=function(e,t){return t?"-"===t?t:T[t]?T[t]:(console.log(`Attempting access ${e} with prompt '${t}'.`),"not a secret"):e},e.Storage.retrieve=async(t,n)=>{const s=e.collections[t];"EncryptionKey"===t&&await s.synchronize1(n),"KeyRecovery"===t&&await s.synchronize1(n);const i=await s.get(n);return b.maybeInflate(i)};e.Storage.store=async(t,n,s)=>{const i=e.decodeClaims(s),a="47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU"===i?.sub,r=e.collections[t];s=b.ensureString(s);if(await(a?r.delete(n,s):r.put(n,s))!==n)throw new Error(`Unable to write credential ${n}.`);return n&&await r.push(a?"delete":"put",n,s),n},e.collections={},["EncryptionKey","KeyRecovery","Team"].forEach((t=>e.collections[t]=new z({name:t}))),console.log("flexstore from",import.meta.url);var P={Credentials:e,Collection:b,ImmutableCollection:v,MutableCollection:z,VersionedCollection:S,VersionCollection:C,Synchronizer:m,WebRTC:a,PromiseWebRTC:r,SharedWebRTC:c,name:u,version:g,storageName:l,storageVersion:4};export{b as Collection,v as ImmutableCollection,z as MutableCollection,r as PromiseWebRTC,c as SharedWebRTC,m as Synchronizer,C as VersionCollection,S as VersionedCollection,a as WebRTC,P as default,u as name,l as storageName,d as storageVersion,g as version};
