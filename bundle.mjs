import e from"@ki1r0y/distributed-security";export{default as Credentials}from"@ki1r0y/distributed-security";const t=/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;function n(){var e=URL.createObjectURL(new Blob),t=e.toString();return URL.revokeObjectURL(e),t.split(/[:\/]/g).pop().toLowerCase()}n.valid=function(e){return t.test(e)};var s=globalThis;const i=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:freestun.net:3478"},{urls:"turn:turn.speed.cloudflare.com:50000",username:"826226244cd6e5edb3f55749b796235f420fe5ee78895e0dd7d2baa45e1f7a8f49e9239e78691ab38b72ce016471f7746f5277dcef84ad79fc60f8020b132c73",credential:"aba9b169546eb6dcc7bfb1cdf34544cf95b5161d602e3b5fa7c8342b2e9802fb"}];class WebRTC{constructor({label:e="",configuration:t=null,uuid:s=n(),debug:r=!1,...a}={}){t??={iceServers:i},Object.assign(this,{label:e,configuration:t,uuid:s,debug:r,...a}),this.resetPeer()}signal(e,t){this.log("sending",e,e.length,JSON.stringify(t).length)}peerVersion=0;resetPeer(){const e=this.peer;e&&(e.onnegotiationneeded=e.onicecandidate=e.onicecandidateerror=e.onconnectionstatechange=null,"new"!==e.connectionState&&e.close());const t=this.peer=new s.RTCPeerConnection(this.configuration);t.versionId=this.peerVersion++,t.onnegotiationneeded=e=>this.negotiationneeded(e),t.onicecandidate=e=>this.onLocalIceCandidate(e),t.onicecandidateerror=e=>this.icecandidateError(e),t.onicegatheringstatechange=e=>"complete"===t.iceGatheringState&&this.onLocalEndIce,t.onconnectionstatechange=e=>this.connectionStateChange(this.peer.connectionState)}onLocalIceCandidate(e){e.candidate&&e.candidate.candidate?this.signal("icecandidate",e.candidate):this.onLocalEndIce()}onLocalEndIce(){}close(){"new"===this.peer.connectionState&&"stable"===this.peer.signalingState||this.resetPeer()}connectionStateChange(e){this.log("state change:",e),["disconnected","failed","closed"].includes(e)&&this.close()}negotiationneeded(){this.log("negotiationnneeded"),this.peer.createOffer().then((e=>(this.peer.setLocalDescription(e),e))).then((e=>this.signal("offer",e))).catch((e=>this.negotiationneededError(e)))}offer(e){this.peer.setRemoteDescription(e).then((e=>this.peer.createAnswer())).then((e=>this.peer.setLocalDescription(e))).then((e=>this.signal("answer",this.peer.localDescription)))}answer(e){this.peer.setRemoteDescription(e)}icecandidate(e){this.peer.addIceCandidate(e).catch((e=>this.icecandidateError(e)))}log(...e){this.debug&&console.log(this.label,this.peer.versionId,...e)}logError(e,t){const n=[this.label,this.peer.versionId,...this.constructor.gatherErrorData(e,t)];return console.error.apply(console,n),n}static gatherErrorData(e,t){return[e+" error:",t.code||t.errorCode||t.status||"",t.url||t.name||"",t.message||t.errorText||t.statusText||t]}icecandidateError(e){701!==(e.code||e.errorCode||e.status)&&this.logError("ice",e)}}class PromiseWebRTC extends WebRTC{constructor({iceTimeout:e=2e3,...t}){super(t),this.iceTimeout=e}get signals(){return this._signalPromise||=new Promise(((e,t)=>this._signalReady={resolve:e,reject:t}))}set signals(e){e.forEach((([e,t])=>this[e](t)))}onLocalIceCandidate(e){this.timer||=setTimeout((()=>this.onLocalEndIce()),this.iceTimeout),super.onLocalIceCandidate(e)}clearIceTimer(){clearTimeout(this.timer),this.timer=null}async onLocalEndIce(){this.clearIceTimer(),this._signalPromise&&(this._signalReady.resolve(this.sending),this.sending=[])}sending=[];signal(e,t){super.signal(e,t),this.sending.push([e,t])}dataChannels=new Map;reportChannels(){const e=Array.from(this.dataChannels.entries()).map((([e,t])=>`${e}:${t.id}`));return`${this.dataChannels.size}/${e.join(", ")}`}noteChannel(e,t,n){const s=e.label,i=this.dataChannels.get(s);return this.log("got data-channel",t,s,"existing:",i,"waiting:",n),this.dataChannels.set(s,e),e.addEventListener("close",(e=>{this.dataChannels.delete(s),this.dataChannels.size||this.peer.getSenders().length||this.close()})),e}createDataChannel(e="data",t={}){return new Promise((n=>{this.log("create data-channel",e,t);let s=this.peer.createDataChannel(e,t);this.noteChannel(s,"explicit"),"open"===s.readyState?setTimeout((()=>n(s)),10):s.onopen=e=>{n(s)}}))}waitingChannels={};getDataChannelPromise(e="data"){return new Promise((t=>{this.log("promise data-channel",e),this.waitingChannels[e]=t}))}resetPeer(){super.resetPeer(),this.connected=new Promise((e=>{this.peer.addEventListener("connectionstatechange",(t=>{"connected"===this.peer.connectionState&&e(!0)}))})),this.peer.addEventListener("datachannel",(e=>{const t=e.channel,n=t.label,s=this.waitingChannels[n];this.noteChannel(t,"datachannel event",s),s&&(delete this.waitingChannels[n],s(t))}))}close(){"failed"===this.peer.connectionState&&this._signalPromise?.reject?.(),super.close(),this.clearIceTimer(),this._signalPromise=this._signalReady=null,this.sending=[]}}const r=1e3;class SharedWebRTC extends PromiseWebRTC{static connections=new Map;static ensure({serviceLabel:e,multiplex:t=!0,...s}){let i=this.connections.get(e);return i||(i=new this({label:e,uuid:n(),multiplex:t,...s}),t&&this.connections.set(e,i)),i}channelId=r;get hasStartedConnecting(){return this.channelId>r}close(e=!0){this.channelId=r,super.close(),e&&this.constructor.connections.delete(this.serviceLabel)}async ensureDataChannel(e,t={},n=null){const s=this.hasStartedConnecting,i=this.channelId++,r="negotiated"===this.multiplex&&s,a=!s/*!negotiated*/&&!!n,o=!s&&n?.length,c=r?{id:i,negotiated:r,...t}:t;s?await this.connected:o&&(this.signals=n);const l=a?this.getDataChannelPromise(e):this.createDataChannel(e,c);return await l}}var a={name:"@kilroy-code/flexstore",version:"0.0.32",description:"Safe and private storage replicated between clients and relays, with realtime updates.",exports:"./index.mjs",imports:{"#wrtc":{node:"@roamhq/wrtc",default:"./lib/browser-wrtc.mjs"},"#persist":{node:"./lib/persist-fs.mjs",default:"./lib/persist-indexeddb.mjs"}},scripts:{test:"jasmine",build:"rollup -c","build-dev":"npx rollup -c --environment NODE_ENV:development"},repository:{type:"git",url:"git+https://github.com/kilroy-code/flexstore.git"},publishConfig:{registry:"https://npm.pkg.github.com"},keywords:["key-value","storage","p2p","client","server","relay","end-to-end","encryption","cryptography","signed","privacy"],author:"howard@ki1r0y.com",license:"MIT",bugs:{url:"https://github.com/kilroy-code/flexstore/issues"},homepage:"https://github.com/kilroy-code/flexstore#readme",dependencies:{"@ki1r0y/distributed-security":"^1.1.3","@roamhq/wrtc":"^0.8.0",uuid4:"^2.0.3"},devDependencies:{"@rollup/plugin-json":"^6.1.0","@rollup/plugin-node-resolve":"15.3","@rollup/plugin-terser":"^0.4.4",jasmine:"^5.7.1",rollup:"4.27"}};const o="flexstore",c=4,{name:l,version:h}=a;class Synchronizer{constructor({serviceName:e="direct",collection:t,serviceLabel:n=t?.serviceLabel||e,channelName:s,uuid:i,rtcConfiguration:r,connection:a,multiplex:o=t?.multiplex,debug:c=t?.debug,minVersion:l=4,maxVersion:h=l}){const d=e.startsWith?.("http");d||void 0!==r||(r={}),o??=a?.multiplex,o??=e.includes?.("/sync")||"negotiated",a??=SharedWebRTC.ensure({serviceLabel:n,configuration:r,multiplex:o,debug:c}),i??=a.uuid,s??=t?.channelName||t.fullName;const u=`${t?.fullLabel||s}/${i}`,g=e.includes?.("/signal/")?e:`${e}/${u}`;Object.assign(this,{serviceName:e,label:u,collection:t,debug:c,minVersion:l,maxVersion:h,uuid:i,rtcConfiguration:r,connection:a,uuid:i,channelName:s,connectionURL:g,connectionStartTime:Date.now(),closed:this.makeResolveablePromise(),hostRequestBase:d&&`${e.replace(/\/(sync|signal)/)}/${s}`}),t?.synchronizers.set(e,this)}static async create(e,t,n={}){const s=new this({collection:e,serviceName:t,...n}),i=s.connectChannel(),r=await i;return r?await r.synchronize():s}async connectChannel(){const{hostRequestBase:e,uuid:t,connection:n,serviceName:s}=this;let i=n.hasStartedConnecting;if(i)i=this.dataChannelPromise=n.ensureDataChannel(this.channelName);else if(this.connectionURL.includes("/signal/answer"))i=this.connectServer();else if(this.connectionURL.includes("/signal/offer")){const e=this.startConnection([]),t=this.connectionURL,n=await this.fetch(t);this.completeConnection(n),i=this.fetch(t,await e)}else if(this.connectionURL.includes("/sync"))i=this.connectServer();else{if("signals"===s)return i=this.startConnection(),null;if(Array.isArray(s))i=this.startConnection(s);else{if(!s.synchronizers)throw new Error(`Unrecognized service format: ${s}.`);i=this.connectDirectTesting(s)}}return await i?this:(console.warn(this.label,"connection failed"),null)}log(...e){this.debug&&console.log(this.label,...e)}get dataChannelPromise(){const e=this._dataChannelPromise;if(!e)throw new Error(`${this.label}: Data channel is not yet promised.`);return e}channelClosedCleanup(){this.collection?.synchronizers.delete(this.serviceName),this.closed.resolve(this)}set dataChannelPromise(e){this._dataChannelPromise=e.then((e=>(e.onmessage=e=>this.receive(e.data),e.onclose=async e=>this.channelClosedCleanup(),e)))}async synchronize(){return await this.dataChannelPromise,await this.startedSynchronization,this}static fragmentId=0;async send(e,...t){const n=JSON.stringify({method:e,params:t}),s=await this.dataChannelPromise,i=s?.readyState||"closed";if("closed"===i||"closing"===i)return;this.log("sends",e,...t);const r=16e3;if(n.length<r)return void s.send(n);const a=Math.ceil(n.length/r),o=this.constructor.fragmentId++,c={method:"fragments",params:[o,a]};s.send(JSON.stringify(c));for(let e=0,t=0;e<a;++e,t+=r){const i={method:"frag",params:[o,e,n.substr(t,r)]};s.send(JSON.stringify(i))}}receive(e){const{method:t,params:n}=JSON.parse(e);this[t](...n)}pendingFragments={};fragments(e,t){this.pendingFragments[e]={remaining:t,message:Array(t)}}frag(e,t,n){let s=this.pendingFragments[e];s.message[t]=n,0===--s.remaining&&(this.receive(s.message.join("")),delete this.pendingFragments[e])}async disconnect(){if("connected"!==this.connection.peer.connectionState)return this.channelClosedCleanup(this.connection.close());return(await this.dataChannelPromise).close(),this.closed}startConnection(e){const{connection:t}=this;return this.log(e?"generating answer":"generating offer"),this.dataChannelPromise=t.ensureDataChannel(this.channelName,{},e),t.signals}completeConnection(e){return this.connection.signals=e,!0}async fetch(e,t=null){const n=t?"POST":"GET";this.debug&&this.log(n,"signals",e,JSON.stringify(t,null,2));const s=await fetch(e,t?{method:n,headers:{"Content-Type":"application/json"},body:JSON.stringify(t)}:{method:n}),i=await s.json();return this.debug&&this.log(n,"responseSignals",e,JSON.stringify(i,null,2)),i}async connectServer(e=this.connectionURL){const t=this.startConnection(),n=await this.fetch(e,await t);return this.completeConnection(n)}async completeSignalsSynchronization(e){await this.completeConnection(e),await this.synchronize()}async connectDirectTesting(e){const t=e.synchronizers.get(this.collection);if(!t)return this._delay=this.makeResolveablePromise(),!1;const n=this.startConnection(),s=await t.startConnection(await n);return t._delay.resolve(),this.completeConnection(s)}makeResolveablePromise(e){let t;const n=new Promise((e=>t=e));return n.resolve=t,n}async versions(e,t){let n=this.version;const s=Math.min(t,this.maxVersion);return s>=Math.max(e,this.minVersion)?n.resolve(s):n.resolve(0)}get version(){return this._version||=this.makeResolveablePromise(setTimeout((()=>this.send("versions",this.minVersion,this.maxVersion)),200))}get startedSynchronization(){return this._startedSynchronization||=this.startSynchronization()}get completedSynchronization(){return this._completedSynchronization||=this.makeResolveablePromise(this.startedSynchronization)}get peerCompletedSynchronization(){return this._peerCompletedSynchronization||=this.makeResolveablePromise()}get bothSidesCompletedSynchronization(){return this.completedSynchronization.then((()=>this.peerCompletedSynchronization))}async reportConnection(){const e=await this.connection.peer.getStats();let t;for(const n of e.values())if("transport"===n.type){t=n;break}let n=t&&e.get(t.selectedCandidatePairId);if(!n)for(const t of e.values())if("candidate-pair"===t.type&&t.selected){n=t;break}if(!n)return void console.warn(this.label,"got stats without candidatePair",Array.from(e.values()));const s=e.get(n.remoteCandidateId),{protocol:i,candidateType:r}=s,a=Date.now();Object.assign(this,{stats:e,transport:t,candidatePair:n,remote:s,protocol:i,candidateType:r,synchronizationStartTime:a}),console.info(this.label,"connected",i,r,((a-this.connectionStartTime)/1e3).toFixed(1))}async startSynchronization(){if(!await this.dataChannelPromise)throw new Error(`No connection for ${this.label}.`);await this.reportConnection();const[e,t]=await Promise.all([this.version,this.collection.tags]);Object.assign(this,{ourTags:t,synchronized:new Set,unsynchronized:new Map,endOfPeerTags:!1}),this.streamTags(t)}async computeHash(t){const n=await e.hashText(t);return e.encodeBase64url(n)}async getHash(e){const t=await this.collection.get(e);return this.computeHash(t||"missing")}async streamTags(e){for(const t of e)this.send("hash",t,await this.getHash(t));this.send("endTags")}async endTags(){await this.startedSynchronization,this.endOfPeerTags=!0,this.cleanUpIfFinished()}synchronizationComplete(e){this.peerCompletedSynchronization.resolve(e)}cleanUpIfFinished(){if(!this.endOfPeerTags||this.unsynchronized.size)return;const e=this.synchronized.size;this.send("synchronizationComplete",e),this.synchronized.clear(),this.unsynchronized.clear(),this.ourTags=this.synchronized=this.unsynchronized=null,console.info(this.label,"completed synchronization",e,"items in",((Date.now()-this.synchronizationStartTime)/1e3).toFixed(1),"seconds"),this.completedSynchronization.resolve(e)}synchronizationPromise(e){return!this.unsynchronized||(!!this.synchronized.has(e)||(this.unsynchronized.get(e)||this.noteRequest(e,"",this.getHash(e))))}async hash(e,t){await this.startedSynchronization;const{ourTags:n,unsynchronized:s}=this;return s.has(e)?null:n.has(e)?this.noteRequest(e,t,this.getHash(e)):this.noteRequest(e,t)}noteRequest(e,t="",n=null){const s=new Promise((s=>{setTimeout((async()=>{if(!t||!n||t!==await n){const s=await this.request(e);t&&!s?.length||(await this.collection.put(e,s,this)?this.log("received/put",e,"their/our hash:",t||"missingTheirs",await n||"missingOurs",s?.length):this.log("unable to put",e)),this.synchronized.add(e)}this.unsynchronized.delete(e),this.cleanUpIfFinished(),s()}))}));return this.unsynchronized.set(e,s),s}request(e){const t=this.makeResolveablePromise(this.send("get",e));return this.unsynchronized.get(e).resolve=t.resolve,t}async get(e){const t=await this.collection.get(e);this.push("put",e,t)}push(e,t,n){this.send(e,t,n)}async put(e,t){const n=this.unsynchronized?.get(e);n?n.resolve(t):await this.collection.put(e,t,this)}delete(e,t){this.collection.delete(e,t,this)}}class PersistIndexedDB{constructor({collection:e,collectionLabel:t=e.fullLabel,dbName:n=o,dbVersion:s=4}={}){this.db_name=t,this.objectStore_name=`${n}:${s}`}get db(){return this._db??=new Promise((e=>{const t=indexedDB.open(this.db_name,this.db_version);t.onupgradeneeded=({oldVersion:e,newVersion:t,target:n})=>this.upgrade(n.result,e,t),this.result(e,t)}))}upgrade(e,t,n){const{objectStore_name:s}=this;e.objectStoreNames.contains(s)||e.createObjectStore(s)}transaction(e="read"){const{objectStore_name:t}=this;return this.db.then((n=>n.objectStoreNames.contains(t)?n.transaction(t,e).objectStore(t):(this._db=null,this.db_version=n.version+1,n.close(),this.transaction(e))))}result(e,t){t.onsuccess=t=>e(t.target.result||"")}list(){return new Promise((e=>{this.transaction("readonly").then((t=>this.result(e,t.getAllKeys())))}))}get(e){return new Promise((t=>{this.transaction("readonly").then((n=>this.result(t,n.get(e))))}))}put(e,t){return new Promise((n=>{this.transaction("readwrite").then((s=>this.result(n,s.put(t,e))))}))}delete(e){return new Promise((t=>{this.transaction("readwrite").then((n=>this.result(t,n.delete(e))))}))}async close(){return this._db?((await this.db).close(),new Promise((e=>setTimeout(e,1e3)))):null}async destroy(){await this.close();const e=window.indexedDB.deleteDatabase(this.db_name);return new Promise(((t,n)=>{e.onsuccess=setTimeout(t,1e3),e.onerror=n}))}}const{CustomEvent:d,EventTarget:u,TextDecoder:g}=globalThis;class Collection extends u{static Persist=PersistIndexedDB;constructor({name:e,label:t=e,services:n=[],preserveDeletions:s=!!n.length,persistenceClass:i=Collection.Persist,dbVersion:r=4,debug:a=!1,multiplex:o,channelName:c,serviceLabel:l}){super(),Object.assign(this,{name:e,label:t,preserveDeletions:s,persistenceClass:i,dbVersion:r,multiplex:o,debug:a,channelName:c,serviceLabel:l,fullName:`${this.constructor.name}/${e}`,fullLabel:`${this.constructor.name}/${t}`}),this.synchronize(...n),i.then?this.persistenceStore=i.then((e=>new e({collection:this}))):this.persistenceStore=new i({collection:this})}async close(){await(await this.persistenceStore).close()}async destroy(){await(await this.persistenceStore).destroy()}static ensureString(e){return"string"!=typeof e?JSON.stringify(e):e}static maybeInflate(e){return e?.startsWith?.("{")?JSON.parse(e):e}static encryptedMimeType="text/encrypted";static async ensureDecrypted(t){if(t.protectedHeader.cty!==this.encryptedMimeType)return t;if(t.decrypted)return t;const n=await e.decrypt(t.text);return t.json=n.json,t.text=n.text,t.payload=n.payload,t.decrypted=n,t}static async sign(t,n){const s=await e.sign(t,n);return this.ensureString(s)}static async verify(t,n={}){t=this.maybeInflate(t);const s=await e.verify(t,n);return s&&(s.signature=t),s}static async verifiedSign(e,t,n=null){const s=await this.sign(e,t);return this.validationFormat(s,n)}static async validationFormat(e,t=null){console.log({type:typeof e,signature:e,tag:t});const n=await this.verify(e);console.log({verified:n});const s=n.subjectTag=n.protectedHeader.sub;return n.tag=t||s,n}async undeletedTags(){const e=await(await this.persistenceStore).list(),t=new Set;return await Promise.all(e.map((async e=>{await this.getVerified({tag:e,synchronize:!1})&&t.add(e)}))),t}get tags(){return this._tagsPromise||=this.undeletedTags()}async addTag(e){(await this.tags).add(e)}async deleteTag(e){(await this.tags).delete(e)}log(...e){this.debug&&console.log(this.fullLabel,...e)}_canonicalizeOptions(t={}){"string"==typeof t&&(t={tag:t});const{owner:n=e.owner,author:s=e.author,tag:i,encryption:r=e.encryption,time:a=Date.now(),...o}=t,c=n&&n!==s?{team:n,member:s,tag:i,encryption:r,time:a,...o}:{tags:[s],tag:i,time:a,encryption:r,...o};return[!0,"team","owner"].includes(c.encryption)&&(c.encryption=n),c}fail(e,t,n){throw new Error(`${n} does not have the authority to ${e} ${JSON.stringify(t)}.`)}async store(t,n={}){let{encryption:s,tag:i,...r}=this._canonicalizeOptions(n);s&&(t=await e.encrypt(t,s),r.contentType=this.constructor.encryptedMimeType);const a=await this.constructor.sign(t,r);return i=await this.put(i,a),i?(await this.push("put",i,a),i):this.fail("store",t,r.member||r.tags[0])}push(e,t,n,s=null){return Promise.all(this.mapSynchronizers((i=>s!==i&&i.push(e,t,n))))}async remove(e={}){let{encryption:t,tag:n,...s}=this._canonicalizeOptions(e);const i=await this.constructor.sign("",s);return n=await this.delete(n,i),n?(await this.push("delete",n,i),n):this.fail("store","",s.member||s.tags[0])}async retrieve(e){const{tag:t,decrypt:n=!0,...s}=e.tag?e:{tag:e},i=await this.getVerified({tag:t,...s});return i&&n?await this.constructor.ensureDecrypted(i):i}async getVerified(e){const{tag:t,synchronize:n=!0,...s}=e.tag?e:{tag:e};n&&await this.synchronize1(t);const i=await this.get(t);return i?this.constructor.verify(i,s):i}async list(e=!1){return e||await this.synchronizeTags(),Array.from((await this.tags).keys())}async match(e,t){const n=await this.retrieve(e),s=n?.json;if(!s)return!1;for(const e in t)if(s[e]!==t[e])return!1;return!0}async findLocal(e){for(const t of await this.list("no-sync"))if(await this.match(t,e))return t;return!1}async find(e){let t=await this.findLocal(e);return t&&(await this.synchronize1(t),await this.match(t,e))?t:(await this.synchronizeTags(),await this.synchronizeData(),t=await this.findLocal(e),t&&await this.match(t,e)?t:null)}requireTag(e){if(!e)throw new Error("A tag is required.")}async get(e){return this.requireTag(e),await(await this.persistenceStore).get(e)}async put(e,t,n=null,s=null){const i=await this.validateForWriting(e,t,"store",n);if(this.log("put",e,n?.label,"validated:",i),!i)return;await this.addTag(i.tag);const r=await this.mergeSignatures(e,i,t,s);return await this.persist(i.tag,r),i.tag}async delete(e,t,n=null){const s=await this.validateForWriting(e,t,"remove",n,"requireTag");if(this.log("delete",e,n?.label,"validated tag:",s?.tag,"preserveDeletions:",this.preserveDeletions),s)return await this.deleteTag(e),this.preserveDeletions?await this.persist2(s):await this.persist2(s,"delete"),s.tag}notifyInvalid(e,t,n=void 0,s="",i){console.warn(this.fullLabel,t,n,e)}async disallowWrite(e,t,n,s){return n?t?n.iat<t.iat?"backdated":this.ownerMatch(t,n)?await this.subjectMatch(s)?null:"wrong hash":"not owner":null:"invalid signature"}async subjectMatch(t){return t.protectedHeader.sub===await e.encodeBase64url(await e.hashBuffer(t.payload))}ownerMatch(e,t){const n=e?.iss||e?.kid,s=t.iss||t.kid;return!(!s||n&&s!==n)}antecedent(e){return e.tag}synchronizeAntecedent(e,t){return e!==t}async validateForWriting(e,t,n,s,i=!1){const r=s?{member:null}:{},a=await this.constructor.verify(t,r);if(!a)return this.notifyInvalid(e,n,"invalid",a,t);a.synchronizer=s,e=a.tag=a.subjectTag=i?e:await this.tagForWriting(e,a);const o=this.antecedent(a),c=this.synchronizeAntecedent(e,o),l=a.existing=o&&await this.getVerified({tag:o,synchronize:c}),h=await this.disallowWrite(e,l?.protectedHeader,a?.protectedHeader,a);return h?this.notifyInvalid(e,n,h,a):(this.emit(a),a)}mergeSignatures(e,t,n){return n}async persist(e,t,n="put"){return(await this.persistenceStore)[n](e,t)}mergeValidation(e){return e}async persist2(e,t="put"){const{tag:n,signature:s}=e,i=this.constructor.ensureString(s),r=await this.persistenceStore;return await r[t](n,i),n}emit(e){this.dispatchEvent(new d("update",{detail:e}))}get itemEmitter(){return this}synchronizers=new Map;mapSynchronizers(e){const t=[];for(const n of this.synchronizers.values())t.push(e(n));return t}get services(){return Array.from(this.synchronizers.keys())}async synchronize(...e){const{synchronizers:t}=this;for(let n of e)t.has(n)||await Synchronizer.create(this,n)}get synchronized(){return Promise.all(this.mapSynchronizers((e=>e.bothSidesCompletedSynchronization)))}async disconnect(...e){e.length||(e=this.services);const{synchronizers:t}=this;for(let n of e){const e=t.get(n);e&&await e.disconnect()}}async ensureSynchronizer(e,t,n){let s=this.synchronizers.get(e);if(s){if(s.connection!==t||s.channelName!==n.label||await s.dataChannelPromise!==n)throw new Error(`Unmatched connection for ${e}.`)}else s=new Synchronizer({serviceName:e,collection:this,debug:this.debug}),s.connection=t,s.dataChannelPromise=Promise.resolve(n),this.synchronizers.set(e,s);return s}promise(e,t){return t}synchronize1(e){return Promise.all(this.mapSynchronizers((t=>t.synchronizationPromise(e))))}async synchronizeTags(){return this.promise("tags",(()=>Promise.resolve()))}async synchronizeData(){return this.promise("data",(()=>Promise.resolve()))}set onupdate(e){e?(this._update=e,this.addEventListener("update",e)):(this.removeEventListener("update",this._update),this._update=e)}get onupdate(){return this._update}}class ImmutableCollection extends Collection{tagForWriting(e,t){return t.protectedHeader.sub}async disallowWrite(e,t,n,s){return n?t?!s.payload.length&&n.iat>t.iat?null:n.iat>t.iat?"rewrite":n.sub!==t.sub?"altered contents":null:s.length&&e!==n.sub?"wrong tag":await this.subjectMatch(s)?null:"wrong hash":"invalid signature"}}class MutableCollection extends Collection{tagForWriting(e,t){return e||t.protectedHeader.sub}}class VersionCollection extends MutableCollection{async tagForWriting(t,n){if(t)return t;const s=n.protectedHeader.ant,i=n.text||(new g).decode(n.payload);return e.encodeBase64url(await e.hashText(s+i))}antecedent(e){const t=e?.protectedHeader;if(!t)return"";const n=t.ant;return"number"==typeof n?"":n}async subjectMatch(e){return!0}emit(e){e.subjectTag=e.protectedHeader.sub,super.emit(e)}}class VersionedCollection extends MutableCollection{constructor({services:e=[],...t}={}){super(t),this.versions=new VersionCollection(t),this.synchronize(...e)}async close(){await this.versions.close(),await super.close()}async destroy(){await this.versions.destroy(),await super.destroy()}recoverTag(e){return Object.assign({},e,{tag:e.protectedHeader.sub})}serviceForVersion(e){return e?.versions||e}servicesForVersion(e){return e.map((e=>this.serviceForVersion(e)))}async synchronize(...e){if(!e.length)return;const t=super.synchronize(...e),n=this.versions.synchronize(...this.servicesForVersion(e));await t,await n}async disconnect(...e){e.length||(e=this.services),await this.versions.disconnect(...this.servicesForVersion(e)),await super.disconnect(...e)}get synchronized(){return super.synchronized.then((()=>this.versions.synchronized))}get itemEmitter(){return this.versions}async getVersions(e){this.requireTag(e);const t=await this.getVerified({tag:e}),n=t?.json;if(!Array.isArray(n))return n;const s=await this.ensureExpanded(t);return this.combineTimestamps(e,null,...s.map((e=>e.json)))}async retrieveTimestamps(e){const t=await this.getVersions(e);return t?Object.keys(t).slice(1).map((e=>parseInt(e))):t}getActiveHash(e,t=e.latest){if(!e)return e;let n=e[t];if(n)return n;let s=0,i=Object.keys(e);for(let e=1;e<i.length&&i[e]<=t;e++)s=i[e];return e[s]}async retrieve(e){let{tag:t,time:n,hash:s,...i}=!e||e.length?{tag:e}:e;if(!s){const e=await this.getVersions(t);if(!e)return e;if(s=this.getActiveHash(e,n),!s)return""}return this.versions.retrieve({tag:s,...i})}async store(t,n={}){let s,{tag:i,encryption:r,...a}=this._canonicalizeOptions(n),o=Date.now(),c=Object.assign({time:o,encryption:r},a);i&&(s=await this.getVersions(i)||{},c.sub=i,s&&(c.ant=s[s.latest])),c.ant||=o;const l=await this.versions.store(t,c);if(!i){const t=await this.versions.get(l);i=e.decodeClaims(this.constructor.maybeInflate(t)).sub,s={}}s.latest=o,s[o]=l;const h=await this.constructor.sign(s,a);return await this.addTag(i),await this.persist(i,h),this.emit({tag:i,subjectTag:i,...await this.constructor.verify(h)}),await this.push("put",i,h),i}async remove(e={}){let{encryption:t,tag:n,...s}=this._canonicalizeOptions(e);const i=await this.getVersions(n);if(!i)return i;if(this.preserveDeletions)await this.store("",s);else{const e=Object.values(i).slice(1),t=await this.constructor.sign("",{sub:n,...s});await Promise.all(e.map((async e=>{await this.versions.delete(e,t),await this.versions.push("delete",e,t)})));const r=await this.constructor.sign("",s);await this.persist(n,r,"delete"),await this.push("delete",n,r)}return await this.deleteTag(n),n}async mergeSignatures(t,n,s,i=null){let r=n,a=n.existing;if(!a)return s;n.protectedHeader.iat<n.existing.protectedHeader.iat&&([a,r]=[r,a]);let o=null;if(!Array.isArray(a.json)&&!Array.isArray(r.json)&&(o=this.missingKeys(a.json,r.json),!o.length))return this.constructor.ensureString(r.signature);const c=await this.ensureExpanded(a),l=await this.ensureExpanded(r),h=c[0].protectedHeader;let d,u,g=h.iss||h.kid,m=[e.owner,e.author,i].includes(g)||!i&&await e.sign("",g).catch((()=>!1)),p=Date.now();const y=i||e.author;function w(e,t){return[].concat(e,t)}if(m){function f(e){return e.map((e=>e.json))}const b=w(f(c),f(l));d=this.combineTimestamps(t,o,...b),u={team:g,member:y,time:p}}else{function v(e){return e.map((e=>e.signature))}d=w(v(c),v(l)),u={tags:[y],time:p}}return await this.constructor.sign(d,u)}ensureExpanded(e){return Array.isArray(e.json)?Promise.all(e.json.map((e=>this.constructor.verify(e)))):[e]}missingKeys(e,t){const n=new Set(Object.values(t));return Object.keys(e).filter((t=>"latest"!==t&&!n.has(e[t])))}combineTimestamps(e,t,n,s,...i){t||=this.missingKeys(n,s);const r={};let a,o,c=0;for(const i in s){if(a=0,"latest"!==i)for(;c<t.length&&(a=t[c])<i;c++)r[a]=n[a];if(a===i){console.warn(this.fullLabel,`Unusual matching timestamp case at time ${a} for tag ${e}.`),o||=Object.keys(s);const l=i+(Math.min(t[c+1]||1/0,s[o.indexOf(i)+1]||1/0)-i)/2;r[i]=n[i],r[l]=s[i]}else r[i]=s[i]}for(;c<t.length;c++)a=t[c],r[a]=n[a];let l=Object.keys(r);return r.latest=l[l.length-1],i.length?this.combineTimestamps(e,void 0,r,...i):r}static async verify(e,t={}){if(e.startsWith?.("[")&&(e=JSON.parse(e)),!Array.isArray(e))return await super.verify(e,t);const n=await Promise.all(e.map((e=>this.verify(e,t))));if(!n.every((e=>e)))return;const s=n[0].protectedHeader;for(const e of["iss","kid","alg","cty"]){const t=s[e],i=n.every((n=>n.protectedHeader[e]===t));if(!i&&!i)return}const{iss:i,kid:r,alg:a,cty:o}=s;return{signature:e,json:n.map((e=>e.json)),protectedHeader:{iss:i,kid:r,alg:a,cty:o,iat:Math.max(...n.map((e=>e.protectedHeader.iat)))}}}async disallowWrite(e,t,n,s){return n?t?this.ownerMatch(t,n)?await this.subjectMatch(s)?null:"wrong hash":"not owner":null:"invalid signature"}ownerMatch(e,t){return!0}}e.author=null,e.owner=null,e.encryption=null,e.synchronize=async(...t)=>Promise.all(Object.values(e.collections).map((e=>e.synchronize(...t)))),e.synchronized=async()=>Promise.all(Object.values(e.collections).map((e=>e.synchronized))),e.disconnect=async(...t)=>Promise.all(Object.values(e.collections).map((e=>e.disconnect(...t)))),e.createAuthor=async t=>{if("-"===t)return e.create(await e.create({prompt:t}));const[n,s]=await Promise.all([e.create(),e.create({prompt:t})]);return e.create(n,s)},e.claimInvitation=async(t,n)=>{const s=await e.collections.Team.retrieve({tag:t});if(!s)throw new Error(`Unable to verify invitation ${t}.`);const i=s.json.recipients;if(1!==i.length)throw new Error(`Invitations should have one member: ${t}`);const r=i[0].header.kid,a=await e.create({prompt:n}),o=await e.create();return await e.changeMembership({tag:t,add:[o,a],remove:[r]}),await e.destroy(r),t};const m={};e.setAnswer=(e,t)=>m[e]=t,e.getUserDeviceSecret=function(e,t){return t?"-"===t?t:m[t]?m[t]:(console.log(`Attempting access ${e} with prompt '${t}'.`),"not a secret"):e},e.Storage.retrieve=async(t,n)=>{const s=e.collections[t];"EncryptionKey"===t&&await s.synchronize1(n),"KeyRecovery"===t&&await s.synchronize1(n);const i=await s.get(n);return Collection.maybeInflate(i)};e.Storage.store=async(t,n,s)=>{const i=e.decodeClaims(s),r="47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU"===i?.sub,a=e.collections[t];s=Collection.ensureString(s);if(await(r?a.delete(n,s):a.put(n,s))!==n)throw new Error(`Unable to write credential ${n}.`);return n&&await a.push(r?"delete":"put",n,s),n},e.collections={},["EncryptionKey","KeyRecovery","Team"].forEach((t=>e.collections[t]=new MutableCollection({name:t}))),console.log("flexstore from",import.meta.url);var p={Credentials:e,Collection:Collection,ImmutableCollection:ImmutableCollection,MutableCollection:MutableCollection,VersionedCollection:VersionedCollection,VersionCollection:VersionCollection,Synchronizer:Synchronizer,WebRTC:WebRTC,PromiseWebRTC:PromiseWebRTC,SharedWebRTC:SharedWebRTC,name:l,version:h,storageName:o,storageVersion:4};export{Collection,ImmutableCollection,MutableCollection,PromiseWebRTC,SharedWebRTC,Synchronizer,VersionCollection,VersionedCollection,WebRTC,p as default,l as name,o as storageName,c as storageVersion,h as version};
