import e from"@ki1r0y/distributed-security";export{default as Credentials}from"@ki1r0y/distributed-security";const t=/^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;function n(){var e=URL.createObjectURL(new Blob),t=e.toString();return URL.revokeObjectURL(e),t.split(/[:\/]/g).pop().toLowerCase()}n.valid=function(e){return t.test(e)};var s=globalThis;const i=[{urls:"stun:stun.l.google.com:19302"},{urls:"stun:freestun.net:3478"},{urls:"turn:turn.speed.cloudflare.com:50000",username:"826226244cd6e5edb3f55749b796235f420fe5ee78895e0dd7d2baa45e1f7a8f49e9239e78691ab38b72ce016471f7746f5277dcef84ad79fc60f8020b132c73",credential:"aba9b169546eb6dcc7bfb1cdf34544cf95b5161d602e3b5fa7c8342b2e9802fb"}];class WebRTC{constructor({label:e="",configuration:t=null,uuid:s=n(),debug:a=!1,...r}={}){t??={iceServers:i},Object.assign(this,{label:e,configuration:t,uuid:s,debug:a,...r}),this.resetPeer()}signal(e,t){this.log("sending",e,e.length,JSON.stringify(t).length)}peerVersion=0;resetPeer(){const e=this.peer;e&&(e.onnegotiationneeded=e.onicecandidate=e.onicecandidateerror=e.onconnectionstatechange=null,"new"!==e.connectionState&&e.close());const t=this.peer=new s.RTCPeerConnection(this.configuration);t.versionId=this.peerVersion++,t.onnegotiationneeded=e=>this.negotiationneeded(e),t.onicecandidate=e=>this.onLocalIceCandidate(e),t.onicecandidateerror=e=>this.icecandidateError(e),t.onicegatheringstatechange=e=>"complete"===t.iceGatheringState&&this.onLocalEndIce,t.onconnectionstatechange=e=>this.connectionStateChange(this.peer.connectionState)}onLocalIceCandidate(e){e.candidate&&e.candidate.candidate?this.signal("icecandidate",e.candidate):this.onLocalEndIce()}onLocalEndIce(){}close(){"new"===this.peer.connectionState&&"stable"===this.peer.signalingState||this.resetPeer()}connectionStateChange(e){this.log("state change:",e),["disconnected","failed","closed"].includes(e)&&this.close()}negotiationneeded(){this.log("negotiationnneeded"),this.peer.createOffer().then((e=>(this.peer.setLocalDescription(e),e))).then((e=>this.signal("offer",e))).catch((e=>this.negotiationneededError(e)))}offer(e){this.peer.setRemoteDescription(e).then((e=>this.peer.createAnswer())).then((e=>this.peer.setLocalDescription(e))).then((e=>this.signal("answer",this.peer.localDescription)))}answer(e){this.peer.setRemoteDescription(e)}icecandidate(e){this.peer.addIceCandidate(e).catch((e=>this.icecandidateError(e)))}log(...e){this.debug&&console.log(this.label,this.peer.versionId,...e)}logError(e,t){const n=[this.label,this.peer.versionId,...this.constructor.gatherErrorData(e,t)];return console.error.apply(console,n),n}static gatherErrorData(e,t){return[e+" error:",t.code||t.errorCode||t.status||"",t.url||t.name||"",t.message||t.errorText||t.statusText||t]}icecandidateError(e){701!==(e.code||e.errorCode||e.status)&&this.logError("ice",e)}}class PromiseWebRTC extends WebRTC{constructor({iceTimeout:e=2e3,...t}){super(t),this.iceTimeout=e}get signals(){return this._signalPromise||=new Promise(((e,t)=>this._signalReady={resolve:e,reject:t}))}set signals(e){e.forEach((([e,t])=>this[e](t)))}onLocalIceCandidate(e){this.timer||=setTimeout((()=>this.onLocalEndIce()),this.iceTimeout),super.onLocalIceCandidate(e)}clearIceTimer(){clearTimeout(this.timer),this.timer=null}async onLocalEndIce(){this.clearIceTimer(),this._signalPromise&&(this._signalReady.resolve(this.sending),this.sending=[])}sending=[];signal(e,t){super.signal(e,t),this.sending.push([e,t])}dataChannels=new Map;reportChannels(){const e=Array.from(this.dataChannels.entries()).map((([e,t])=>`${e}:${t.id}`));return`${this.dataChannels.size}/${e.join(", ")}`}noteChannel(e,t,n){const s=e.label,i=this.dataChannels.get(s);return this.log("got data-channel",t,s,"existing:",i,"waiting:",n),this.dataChannels.set(s,e),e.addEventListener("close",(e=>{this.dataChannels.delete(s),this.dataChannels.size||this.peer.getSenders().length||this.close()})),e}createDataChannel(e="data",t={}){return new Promise((n=>{this.log("create data-channel",e,t);let s=this.peer.createDataChannel(e,t);this.noteChannel(s,"explicit"),"open"===s.readyState?setTimeout((()=>n(s)),10):s.onopen=e=>{n(s)}}))}waitingChannels={};getDataChannelPromise(e="data"){return new Promise((t=>{this.log("promise data-channel",e),this.waitingChannels[e]=t}))}resetPeer(){super.resetPeer(),this.connected=new Promise((e=>{this.peer.addEventListener("connectionstatechange",(t=>{"connected"===this.peer.connectionState&&e(!0)}))})),this.peer.addEventListener("datachannel",(e=>{const t=e.channel,n=t.label,s=this.waitingChannels[n];this.noteChannel(t,"datachannel event",s),s&&(delete this.waitingChannels[n],s(t))}))}close(){"failed"===this.peer.connectionState&&this._signalPromise?.reject?.(),super.close(),this.clearIceTimer(),this._signalPromise=this._signalReady=null,this.sending=[]}}const a=1e3;class SharedWebRTC extends PromiseWebRTC{static connections=new Map;static ensure({serviceLabel:e,multiplex:t=!0,...s}){let i=this.connections.get(e);return i||(i=new this({label:e,uuid:n(),multiplex:t,...s}),t&&this.connections.set(e,i)),i}channelId=a;get hasStartedConnecting(){return this.channelId>a}close(e=!0){this.channelId=a,super.close(),e&&this.constructor.connections.delete(this.serviceLabel)}async ensureDataChannel(e,t={},n=null){const s=this.hasStartedConnecting,i=this.channelId++,a="negotiated"===this.multiplex&&s,r=!s/*!negotiated*/&&!!n,o=!s&&n?.length,c=a?{id:i,negotiated:a,...t}:t;s?await this.connected:o&&(this.signals=n);const h=r?this.getDataChannelPromise(e):this.createDataChannel(e,c);return await h}}var r={name:"@kilroy-code/flexstore",version:"0.0.38"};const o="flexstore",c=4,{name:h,version:l}=r;class Synchronizer{constructor({serviceName:e="direct",collection:t,serviceLabel:n=t?.serviceLabel||e,channelName:s,uuid:i,rtcConfiguration:a,connection:r,multiplex:o=t?.multiplex,debug:c=t?.debug,minVersion:h=4,maxVersion:l=h}){const d=e.startsWith?.("http");d||void 0!==a||(a={}),o??=r?.multiplex,o??=e.includes?.("/sync")||"negotiated",r??=SharedWebRTC.ensure({serviceLabel:n,configuration:a,multiplex:o,debug:c}),i??=r.uuid,s??=t?.channelName||t.fullName;const u=`${t?.fullLabel||s}/${i}`,g=e.includes?.("/signal/")?e:`${e}/${u}`;Object.assign(this,{serviceName:e,label:u,collection:t,debug:c,minVersion:h,maxVersion:l,uuid:i,rtcConfiguration:a,connection:r,uuid:i,channelName:s,connectionURL:g,connectionStartTime:Date.now(),closed:this.makeResolveablePromise(),hostRequestBase:d&&`${e.replace(/\/(sync|signal)/)}/${s}`}),t?.synchronizers.set(e,this)}static async create(e,t,n={}){const s=new this({collection:e,serviceName:t,...n}),i=s.connectChannel(),a=await i;return a?await a.synchronize():s}async connectChannel(){const{hostRequestBase:e,uuid:t,connection:n,serviceName:s}=this;let i=n.hasStartedConnecting;if(i)i=this.dataChannelPromise=n.ensureDataChannel(this.channelName);else if(this.connectionURL.includes("/signal/answer"))i=this.connectServer();else if(this.connectionURL.includes("/signal/offer")){const e=this.startConnection([]),t=this.connectionURL,n=await this.fetch(t);this.completeConnection(n),i=this.fetch(t,await e)}else if(this.connectionURL.includes("/sync"))i=this.connectServer();else{if("signals"===s)return i=this.startConnection(),null;if(Array.isArray(s))i=this.startConnection(s);else{if(!s.synchronizers)throw new Error(`Unrecognized service format: ${s}.`);i=this.connectDirectTesting(s)}}return await i?this:(console.warn(this.label,"connection failed"),null)}log(...e){this.debug&&console.log(this.label,...e)}get dataChannelPromise(){const e=this._dataChannelPromise;if(!e)throw new Error(`${this.label}: Data channel is not yet promised.`);return e}channelClosedCleanup(){this.collection?.synchronizers.delete(this.serviceName),this.closed.resolve(this)}set dataChannelPromise(e){this._dataChannelPromise=e.then((e=>(e.onmessage=e=>this.receive(e.data),e.onclose=async e=>this.channelClosedCleanup(),e)))}async synchronize(){return await this.dataChannelPromise,await this.startedSynchronization,this}static fragmentId=0;async send(e,...t){const n=JSON.stringify({method:e,params:t}),s=await this.dataChannelPromise,i=s?.readyState||"closed";if("closed"===i||"closing"===i)return;this.log("sends",e,...t);const a=16e3;if(n.length<a)return void s.send(n);const r=Math.ceil(n.length/a),o=this.constructor.fragmentId++,c={method:"fragments",params:[o,r]};s.send(JSON.stringify(c));for(let e=0,t=0;e<r;++e,t+=a){const i={method:"frag",params:[o,e,n.substr(t,a)]};s.send(JSON.stringify(i))}}receive(e){const{method:t,params:n}=JSON.parse(e);this[t](...n)}pendingFragments={};fragments(e,t){this.pendingFragments[e]={remaining:t,message:Array(t)}}frag(e,t,n){let s=this.pendingFragments[e];s.message[t]=n,0===--s.remaining&&(this.receive(s.message.join("")),delete this.pendingFragments[e])}async disconnect(){if("connected"!==this.connection.peer.connectionState)return this.channelClosedCleanup(this.connection.close());return(await this.dataChannelPromise).close(),this.closed}startConnection(e){const{connection:t}=this;return this.log(e?"generating answer":"generating offer"),this.dataChannelPromise=t.ensureDataChannel(this.channelName,{},e),t.signals}completeConnection(e){return this.connection.signals=e,!0}async fetch(e,t=null){const n=t?"POST":"GET";this.debug&&this.log(n,"signals",e,JSON.stringify(t,null,2));const s=await fetch(e,t?{method:n,headers:{"Content-Type":"application/json"},body:JSON.stringify(t)}:{method:n}).catch((()=>null));if(!s?.ok)return console.error(s?.statusText||"failed",e),null;const i=await s.json();return this.debug&&this.log(n,"responseSignals",e,JSON.stringify(i,null,2)),i}async connectServer(e=this.connectionURL){const t=this.startConnection(),n=await this.fetch(e,await t);try{return this.completeConnection(n)}catch(s){throw new Error(`While connecting ${e}, our signals: ${t}, their signals: ${n}.`,s)}}async completeSignalsSynchronization(e){await this.completeConnection(e),await this.synchronize()}async connectDirectTesting(e){const t=e.synchronizers.get(this.collection);if(!t)return this._delay=this.makeResolveablePromise(),!1;const n=this.startConnection(),s=await t.startConnection(await n);return t._delay.resolve(),this.completeConnection(s)}makeResolveablePromise(e){let t;const n=new Promise((e=>t=e));return n.resolve=t,n}async versions(e,t){let n=this.version;const s=Math.min(t,this.maxVersion);return s>=Math.max(e,this.minVersion)?n.resolve(s):n.resolve(0)}get version(){return this._version||=this.makeResolveablePromise(setTimeout((()=>this.send("versions",this.minVersion,this.maxVersion)),200))}get startedSynchronization(){return this._startedSynchronization||=this.startSynchronization()}get completedSynchronization(){return this._completedSynchronization||=this.makeResolveablePromise(this.startedSynchronization)}get peerCompletedSynchronization(){return this._peerCompletedSynchronization||=this.makeResolveablePromise()}get bothSidesCompletedSynchronization(){return this.completedSynchronization.then((()=>this.peerCompletedSynchronization))}async reportConnection(){const e=await this.connection.peer.getStats();let t;for(const n of e.values())if("transport"===n.type){t=n;break}let n=t&&e.get(t.selectedCandidatePairId);if(!n)for(const t of e.values())if("candidate-pair"===t.type&&t.selected){n=t;break}if(!n)return void console.warn(this.label,"got stats without candidatePair",Array.from(e.values()));const s=e.get(n.remoteCandidateId),{protocol:i,candidateType:a}=s,r=Date.now();Object.assign(this,{stats:e,transport:t,candidatePair:n,remote:s,protocol:i,candidateType:a,synchronizationStartTime:r}),console.info(this.label,"connected",i,a,((r-this.connectionStartTime)/1e3).toFixed(1))}async startSynchronization(){if(!await this.dataChannelPromise)throw new Error(`No connection for ${this.label}.`);const e=new Set(await this.collection.tags);await this.reportConnection(),await this.version,Object.assign(this,{ourTags:e,unsynchronized:new Map,checkedTags:new Set,endOfPeerTags:!1}),this.streamTags(e)}async computeHash(t){const n=await e.hashText(t);return e.encodeBase64url(n)}async getHash(e){const t=await this.collection.get(e);return this.computeHash(t||"missing")}async streamTags(e){for(const t of e)this.send("hash",t,await this.getHash(t));this.send("endTags")}async endTags(){await this.startedSynchronization,this.endOfPeerTags=!0,this.cleanUpIfFinished()}synchronizationComplete(e){this.peerCompletedSynchronization.resolve(e)}cleanUpIfFinished(){if(!this.endOfPeerTags||this.unsynchronized.size)return;const e=this.checkedTags.size;this.send("synchronizationComplete",e),this.checkedTags.clear(),this.unsynchronized.clear(),this.ourTags=this.synchronized=this.unsynchronized=null,console.info(this.label,"completed synchronization",e,"items in",((Date.now()-this.synchronizationStartTime)/1e3).toFixed(1),"seconds"),this.completedSynchronization.resolve(e)}synchronizationPromise(e){return!this.unsynchronized||(!!this.checkedTags.has(e)||(this.unsynchronized.get(e)||this.ensureSynchronizedTag(e,"",this.getHash(e))))}async hash(e,t){await this.startedSynchronization;const{ourTags:n,unsynchronized:s}=this;return this.log('received "hash"',{tag:e,hash:t,ourTags:n,unsynchronized:s}),s.has(e)?null:n.has(e)?this.ensureSynchronizedTag(e,t,this.getHash(e)):this.ensureSynchronizedTag(e,t)}ensureSynchronizedTag(e,t="",n=null){const s=new Promise((s=>{setTimeout((async()=>{if(!t||!n||t!==await n){const s=await this.request(e);t&&!s?.length||(await this.collection.put(e,s,this)?this.log("received/put",e,"their/our hash:",t||"missingTheirs",await n||"missingOurs",s?.length):this.log("unable to put",e))}this.checkedTags.add(e),this.unsynchronized.delete(e),this.cleanUpIfFinished(),s()}))}));return this.unsynchronized.set(e,s),s}request(e){const t=this.makeResolveablePromise(this.send("get",e));return this.unsynchronized.get(e).resolve=t.resolve,t}async get(e){const t=await this.collection.get(e);this.push("put",e,t)}push(e,t,n){this.send(e,t,n)}async put(e,t){const n=this.unsynchronized?.get(e);n?n.resolve(t):await this.collection.put(e,t,this)}delete(e,t){this.collection.delete(e,t,this)}}class Cache extends Map{constructor(e,t=0){super(),this.maxSize=e,this.defaultTimeToLive=t,this._nextWriteIndex=0,this._keyList=Array(e),this._timers=new Map}set(e,t,n=this.defaultTimeToLive){let s=this._nextWriteIndex;this.delete(this._keyList[s]),this._keyList[s]=e,this._nextWriteIndex=(s+1)%this.maxSize,this._timers.has(e)&&clearTimeout(this._timers.get(e)),super.set(e,t),n&&this._timers.set(e,setTimeout((()=>this.delete(e)),n))}delete(e){return this._timers.has(e)&&clearTimeout(this._timers.get(e)),this._timers.delete(e),super.delete(e)}clear(e=this.maxSize){this.maxSize=e,this._keyList=Array(e),this._nextWriteIndex=0,super.clear();for(const e of this._timers.values())clearTimeout(e);this._timers.clear()}}class StorageBase{constructor({name:e,baseName:t="Storage",maxSerializerSize:n=1e3,debug:s=!1}){const i=`${t}/${e}`,a=new Cache(n);Object.assign(this,{name:e,baseName:t,fullName:i,debug:s,serializer:a})}async list(){return this.serialize("",((e,t)=>this.listInternal(t,e)))}async get(e){return this.serialize(e,((e,t)=>this.getInternal(t,e)))}async delete(e){return this.serialize(e,((e,t)=>this.deleteInternal(t,e)))}async put(e,t){return this.serialize(e,((e,n)=>this.putInternal(n,t,e)))}log(...e){this.debug&&console.log(this.name,...e)}async serialize(e,t){const{serializer:n,ready:s}=this;let i=n.get(e)||s;return i=i.then((async()=>t(await this.ready,this.path(e)))),n.set(e,i),await i}}const{Response:d,URL:u}=globalThis;class StorageCache extends StorageBase{constructor(...e){super(...e),this.stripper=new RegExp(`^/${this.fullName}/`),this.ready=caches.open(this.fullName)}async listInternal(e,t){return(await t.keys()||[]).map((e=>this.tag(e.url)))}async getInternal(e,t){const n=await t.match(e);return n?.json()}deleteInternal(e,t){return t.delete(e)}putInternal(e,t,n){return n.put(e,d.json(t))}path(e){return`/${this.fullName}/${e}`}tag(e){return new u(e).pathname.replace(this.stripper,"")}destroy(){return caches.delete(this.fullName)}}const{CustomEvent:g,EventTarget:m,TextDecoder:y}=globalThis;class Collection extends m{constructor({name:e,label:t=e,services:n=[],preserveDeletions:s=!!n.length,persistenceClass:i=StorageCache,dbVersion:a=4,persistenceBase:r=`${o}_${a}`,debug:c=!1,multiplex:h,channelName:l,serviceLabel:d}){super(),Object.assign(this,{name:e,label:t,preserveDeletions:s,persistenceClass:i,dbVersion:a,multiplex:h,debug:c,channelName:l,serviceLabel:d,fullName:`${this.constructor.name}/${e}`,fullLabel:`${this.constructor.name}/${t}`}),this.synchronize(...n);const u={name:this.fullLabel,baseName:r,debug:c};i.then?this.persistenceStore=i.then((e=>new e(u))):this.persistenceStore=new i(u)}async close(){await(await this.persistenceStore).close()}async destroy(){await(await this.persistenceStore).destroy()}static ensureString(e){return"string"!=typeof e?JSON.stringify(e):e}static maybeInflate(e){return e?.startsWith?.("{")?JSON.parse(e):e}static encryptedMimeType="text/encrypted";static async ensureDecrypted(t){if(t.protectedHeader.cty!==this.encryptedMimeType)return t;if(t.decrypted)return t;const n=await e.decrypt(t.text);return t.json=n.json,t.text=n.text,t.payload=n.payload,t.decrypted=n,t}static async sign(t,n){const s=await e.sign(t,n);return this.ensureString(s)}static async verify(t,n={}){t=this.maybeInflate(t);const s=await e.verify(t,n);return s&&(s.signature=t),s}static async verifiedSign(e,t,n=null){const s=await this.sign(e,t);return this.validationFormat(s,n)}static async validationFormat(e,t=null){const n=await this.verify(e),s=n.subjectTag=n.protectedHeader.sub;return n.tag=t||s,n}async undeletedTags(){const e=await(await this.persistenceStore).list(),t=new Set;return await Promise.all(e.map((async e=>{await this.getVerified({tag:e,synchronize:!1})&&t.add(e)}))),t}get tags(){return this._tagsPromise||=this.undeletedTags()}async addTag(e){(await this.tags).add(e)}async deleteTag(e){(await this.tags).delete(e)}log(...e){this.debug&&console.log(this.fullLabel,...e)}_canonicalizeOptions(t={}){"string"==typeof t&&(t={tag:t});const{owner:n=e.owner,author:s=e.author,tag:i,encryption:a=e.encryption,time:r=Date.now(),...o}=t,c=n&&n!==s?{team:n,member:s,tag:i,encryption:a,time:r,...o}:{tags:[s],tag:i,time:r,encryption:a,...o};return[!0,"team","owner"].includes(c.encryption)&&(c.encryption=n),c}fail(e,t,n){throw new Error(`${n} does not have the authority to ${e} ${this.fullName} ${JSON.stringify(t)}.`)}async store(t,n={}){let{encryption:s,tag:i,...a}=this._canonicalizeOptions(n);s&&(t=await e.encrypt(t,s),a.contentType=this.constructor.encryptedMimeType);const r=await this.constructor.sign(t,a);return i=await this.put(i,r),i?(await this.push("put",i,r),i):this.fail("store",t,a.member||a.tags[0])}push(e,t,n,s=null){return Promise.all(this.mapSynchronizers((i=>s!==i&&i.push(e,t,n))))}async remove(e={}){let{encryption:t,tag:n,...s}=this._canonicalizeOptions(e);const i=await this.constructor.sign("",s);return n=await this.delete(n,i),n?(await this.push("delete",n,i),n):this.fail("store","",s.member||s.tags[0])}async retrieve(e){const{tag:t,decrypt:n=!0,...s}=e.tag?e:{tag:e},i=await this.getVerified({tag:t,...s});return i?n?await this.constructor.ensureDecrypted(i):i:""}async getVerified(e){const{tag:t,synchronize:n=!0,...s}=e.tag?e:{tag:e};n&&await this.synchronize1(t);const i=await this.get(t);return i?this.constructor.verify(i,s):i}async list(e=!1){return e||await this.synchronizeTags(),Array.from((await this.tags).keys())}async match(e,t){const n=await this.retrieve(e),s=n?.json;if(!s)return!1;for(const e in t)if(s[e]!==t[e])return!1;return!0}async findLocal(e){for(const t of await this.list("no-sync"))if(await this.match(t,e))return t;return!1}async find(e){let t=await this.findLocal(e);return t&&(await this.synchronize1(t),await this.match(t,e))?t:(await this.synchronizeTags(),await this.synchronizeData(),t=await this.findLocal(e),t&&await this.match(t,e)?t:null)}requireTag(e){if(!e)throw new Error("A tag is required.")}async get(e){return this.requireTag(e),await(await this.persistenceStore).get(e)}async put(e,t,n=null,s=null){const i=await this.validateForWriting(e,t,"store",n);if(this.log("put",{tag:i?.tag||e,synchronizer:n?.label,json:i?.json}),!i)return;await this.addTag(i.tag);const a=await this.mergeSignatures(e,i,t,s);return await this.persist(i.tag,a),i.tag}async delete(e,t,n=null){const s=await this.validateForWriting(e,t,"remove",n,"requireTag");if(this.log("delete",e,n?.label,"validated tag:",s?.tag,"preserveDeletions:",this.preserveDeletions),s)return await this.deleteTag(e),this.preserveDeletions?await this.persist2(s):await this.persist2(s,"delete"),s.tag}notifyInvalid(e,t,n=void 0,s="",i){console.warn(this.fullLabel,t,n,e)}async disallowWrite(e,t,n,s){return n?t?n.iat<t.iat?"backdated":this.ownerMatch(t,n)?await this.subjectMatch(s)?null:"wrong hash":"not owner":null:"invalid signature"}async subjectMatch(t){return t.protectedHeader.sub===await e.encodeBase64url(await e.hashBuffer(t.payload))}ownerMatch(e,t){const n=e?.iss||e?.kid,s=t.iss||t.kid;return!(!s||n&&s!==n)}antecedent(e){return e.tag}synchronizeAntecedent(e,t){return e!==t}async validateForWriting(e,t,n,s,i=!1){const a=s?{member:null}:{},r=await this.constructor.verify(t,a);if(!r)return this.notifyInvalid(e,n,"invalid",r,t);r.synchronizer=s,e=r.tag=r.subjectTag=i?e:await this.tagForWriting(e,r);const o=this.antecedent(r),c=this.synchronizeAntecedent(e,o),h=r.existing=o&&await this.getVerified({tag:o,synchronize:c}),l=await this.disallowWrite(e,h?.protectedHeader,r?.protectedHeader,r);return l?this.notifyInvalid(e,n,l,r):(this.log("emit",e,r.json),this.emit(r),r)}mergeSignatures(e,t,n){return n}async persist(e,t,n="put"){return(await this.persistenceStore)[n](e,t)}mergeValidation(e){return e}async persist2(e,t="put"){const{tag:n,signature:s}=e,i=this.constructor.ensureString(s),a=await this.persistenceStore;return await a[t](n,i),n}emit(e){this.dispatchEvent(new g("update",{detail:e}))}get itemEmitter(){return this}synchronizers=new Map;mapSynchronizers(e){const t=[];for(const n of this.synchronizers.values())t.push(e(n));return t}get services(){return Array.from(this.synchronizers.keys())}async synchronize(...e){const{synchronizers:t}=this;for(let n of e)t.has(n)||await Synchronizer.create(this,n)}get synchronized(){return Promise.all(this.mapSynchronizers((e=>e.bothSidesCompletedSynchronization)))}async disconnect(...e){e.length||(e=this.services);const{synchronizers:t}=this;for(let n of e){const e=t.get(n);e&&await e.disconnect()}}async ensureSynchronizer(e,t,n){let s=this.synchronizers.get(e);if(s){if(s.connection!==t||s.channelName!==n.label||await s.dataChannelPromise!==n)throw new Error(`Unmatched connection for ${e}.`)}else s=new Synchronizer({serviceName:e,collection:this,debug:this.debug}),s.connection=t,s.dataChannelPromise=Promise.resolve(n),this.synchronizers.set(e,s);return s}promise(e,t){return t}synchronize1(e){return Promise.all(this.mapSynchronizers((t=>t.synchronizationPromise(e))))}async synchronizeTags(){return this.promise("tags",(()=>Promise.resolve()))}async synchronizeData(){return this.promise("data",(()=>Promise.resolve()))}set onupdate(e){e?(this._update=e,this.addEventListener("update",e)):(this.removeEventListener("update",this._update),this._update=e)}get onupdate(){return this._update}}class ImmutableCollection extends Collection{tagForWriting(e,t){return t.protectedHeader.sub}async disallowWrite(e,t,n,s){return n?t?!s.payload.length&&n.iat>t.iat?null:n.iat>t.iat?"rewrite":n.sub!==t.sub?"altered contents":null:s.length&&e!==n.sub?"wrong tag":await this.subjectMatch(s)?null:"wrong hash":"invalid signature"}}class MutableCollection extends Collection{tagForWriting(e,t){return e||t.protectedHeader.sub}}class VersionCollection extends MutableCollection{async tagForWriting(t,n){if(t)return t;const s=n.protectedHeader.ant,i=n.text||(new y).decode(n.payload);return e.encodeBase64url(await e.hashText(s+i))}antecedent(e){const t=e?.protectedHeader;if(!t)return"";const n=t.ant;return"number"==typeof n?"":n}async subjectMatch(e){return!0}emit(e){e.subjectTag=e.protectedHeader.sub,super.emit(e)}}class VersionedCollection extends MutableCollection{constructor({services:e=[],...t}={}){super(t),this.versions=new VersionCollection(t),this.synchronize(...e)}async close(){await this.versions.close(),await super.close()}async destroy(){await this.versions.destroy(),await super.destroy()}recoverTag(e){return Object.assign({},e,{tag:e.protectedHeader.sub})}serviceForVersion(e){return e?.versions||e}servicesForVersion(e){return e.map((e=>this.serviceForVersion(e)))}async synchronize(...e){if(!e.length)return;const t=super.synchronize(...e),n=this.versions.synchronize(...this.servicesForVersion(e));await t,await n}async disconnect(...e){e.length||(e=this.services),await this.versions.disconnect(...this.servicesForVersion(e)),await super.disconnect(...e)}get synchronized(){return super.synchronized.then((()=>this.versions.synchronized))}get itemEmitter(){return this.versions}async getVersions(e){this.requireTag(e);const t=await this.getVerified({tag:e}),n=t?.json;if(!Array.isArray(n))return n;const s=await this.ensureExpanded(t);return this.combineTimestamps(e,null,...s.map((e=>e.json)))}async retrieveTimestamps(e){const t=await this.getVersions(e);return t?Object.keys(t).slice(1).map((e=>parseInt(e))):t}getActiveHash(e,t=e.latest){if(!e)return e;let n=e[t];if(n)return n;let s=0,i=Object.keys(e);for(let e=1;e<i.length&&i[e]<=t;e++)s=i[e];return e[s]}async retrieve(e){let{tag:t,time:n,hash:s,...i}=!e||e.length?{tag:e}:e;if(!s){const e=await this.getVersions(t);if(!e)return e;if(s=this.getActiveHash(e,n),!s)return""}return this.versions.retrieve({tag:s,...i})}async store(t,n={}){let s,{tag:i,encryption:a,...r}=this._canonicalizeOptions(n),o=Date.now(),c=Object.assign({time:o,encryption:a},r);i&&(s=await this.getVersions(i)||{},c.sub=i,s&&(c.ant=s[s.latest])),c.ant||=o;const h=await this.versions.store(t,c);if(!i){const t=await this.versions.get(h);i=e.decodeClaims(this.constructor.maybeInflate(t)).sub,s={}}s.latest=o,s[o]=h;const l=await this.constructor.sign(s,r);return await this.addTag(i),await this.persist(i,l),this.emit({tag:i,subjectTag:i,...await this.constructor.verify(l)}),await this.push("put",i,l),i}async remove(e={}){let{encryption:t,tag:n,...s}=this._canonicalizeOptions(e);const i=await this.getVersions(n);if(!i)return i;if(this.preserveDeletions)await this.store("",s);else{const e=Object.values(i).slice(1),t=await this.constructor.sign("",{sub:n,...s});await Promise.all(e.map((async e=>{await this.versions.delete(e,t),await this.versions.push("delete",e,t)})));const a=await this.constructor.sign("",s);await this.persist(n,a,"delete"),await this.push("delete",n,a)}return await this.deleteTag(n),n}async mergeSignatures(t,n,s,i=null){let a=n,r=n.existing;if(!r)return s;n.protectedHeader.iat<n.existing.protectedHeader.iat&&([r,a]=[a,r]);let o=null;if(!Array.isArray(r.json)&&!Array.isArray(a.json)&&(o=this.missingKeys(r.json,a.json),!o.length))return this.constructor.ensureString(a.signature);const c=await this.ensureExpanded(r),h=await this.ensureExpanded(a),l=c[0].protectedHeader;let d,u,g=l.iss||l.kid,m=[e.owner,e.author,i].includes(g)||!i&&await e.sign("",g).catch((()=>!1)),y=Date.now();const p=i||e.author;function w(e,t){return[].concat(e,t)}if(m){function f(e){return e.map((e=>e.json))}const b=w(f(c),f(h));d=this.combineTimestamps(t,o,...b),u={team:g,member:p,time:y}}else{function v(e){return e.map((e=>e.signature))}d=w(v(c),v(h)),u={tags:[p],time:y}}return await this.constructor.sign(d,u)}ensureExpanded(e){return Array.isArray(e.json)?Promise.all(e.json.map((e=>this.constructor.verify(e)))):[e]}missingKeys(e,t){const n=new Set(Object.values(t));return Object.keys(e).filter((t=>"latest"!==t&&!n.has(e[t])))}combineTimestamps(e,t,n,s,...i){t||=this.missingKeys(n,s);const a={};let r,o,c=0;for(const i in s){if(r=0,"latest"!==i)for(;c<t.length&&(r=t[c])<i;c++)a[r]=n[r];if(r===i){console.warn(this.fullLabel,`Unusual matching timestamp case at time ${r} for tag ${e}.`),o||=Object.keys(s);const h=i+(Math.min(t[c+1]||1/0,s[o.indexOf(i)+1]||1/0)-i)/2;a[i]=n[i],a[h]=s[i]}else a[i]=s[i]}for(;c<t.length;c++)r=t[c],a[r]=n[r];let h=Object.keys(a);return a.latest=h[h.length-1],i.length?this.combineTimestamps(e,void 0,a,...i):a}static async verify(e,t={}){if(e.startsWith?.("[")&&(e=JSON.parse(e)),!Array.isArray(e))return await super.verify(e,t);const n=await Promise.all(e.map((e=>this.verify(e,t))));if(!n.every((e=>e)))return;const s=n[0].protectedHeader;for(const e of["iss","kid","alg","cty"]){const t=s[e],i=n.every((n=>n.protectedHeader[e]===t));if(!i&&!i)return}const{iss:i,kid:a,alg:r,cty:o}=s;return{signature:e,json:n.map((e=>e.json)),protectedHeader:{iss:i,kid:a,alg:r,cty:o,iat:Math.max(...n.map((e=>e.protectedHeader.iat)))}}}async disallowWrite(e,t,n,s){return n?t?this.ownerMatch(t,n)?await this.subjectMatch(s)?null:"wrong hash":"not owner":null:"invalid signature"}ownerMatch(e,t){return!0}}e.author=null,e.owner=null,e.encryption=null,e.synchronize=async(...t)=>Promise.all(Object.values(e.collections).map((e=>e.synchronize(...t)))),e.synchronized=async()=>Promise.all(Object.values(e.collections).map((e=>e.synchronized))),e.disconnect=async(...t)=>Promise.all(Object.values(e.collections).map((e=>e.disconnect(...t)))),e.createAuthor=async t=>{if("-"===t)return e.create(await e.create({prompt:t}));const[n,s]=await Promise.all([e.create(),e.create({prompt:t})]);return e.create(n,s)},e.claimInvitation=async(t,n)=>{const s=await e.collections.Team.retrieve({tag:t});if(!s)throw new Error(`Unable to verify invitation ${t}.`);const i=s.json.recipients;if(1!==i.length)throw new Error(`Invitations should have one member: ${t}`);const a=i[0].header.kid,r=await e.create({prompt:n}),o=await e.create();return await e.changeMembership({tag:t,add:[o,r],remove:[a]}),await e.changeMembership({tag:t,remove:[a]}),await e.destroy(a),t};const p={};e.setAnswer=(e,t)=>p[e]=t,e.getUserDeviceSecret=function(e,t){return t?"-"===t?t:p[t]?p[t]:(console.log(`Attempting access ${e} with prompt '${t}'.`),"not a secret"):e},e.Storage.retrieve=async(t,n)=>{const s=e.collections[t];"EncryptionKey"===t&&await s.synchronize1(n),"KeyRecovery"===t&&await s.synchronize1(n);const i=await s.get(n);return Collection.maybeInflate(i)};e.Storage.store=async(t,n,s)=>{const i=e.decodeClaims(s),a="47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU"===i?.sub,r=e.collections[t];s=Collection.ensureString(s);if(await(a?r.delete(n,s):r.put(n,s))!==n)throw new Error(`Unable to write credential ${n}.`);return n&&await r.push(a?"delete":"put",n,s),n},e.Storage.destroy=async()=>{await e.clear(),await Promise.all(Object.values(e.collections).map((async e=>{await e.disconnect();(await e.persistenceStore).destroy()}))),await e.wipeDeviceKeys()},e.collections={},["EncryptionKey","KeyRecovery","Team"].forEach((t=>e.collections[t]=new MutableCollection({name:t}))),console.log(`${h} ${l} from ${import.meta.url}.`);var w={Credentials:e,Collection:Collection,ImmutableCollection:ImmutableCollection,MutableCollection:MutableCollection,VersionedCollection:VersionedCollection,VersionCollection:VersionCollection,Synchronizer:Synchronizer,WebRTC:WebRTC,PromiseWebRTC:PromiseWebRTC,SharedWebRTC:SharedWebRTC,name:h,version:l,storageName:o,storageVersion:4};export{Collection,ImmutableCollection,MutableCollection,PromiseWebRTC,SharedWebRTC,Synchronizer,VersionCollection,VersionedCollection,WebRTC,w as default,h as name,o as storageName,c as storageVersion,l as version};
